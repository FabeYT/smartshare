<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETKn Share - Erweiterte Dateifreigabe zwischen Geräten</title>
    <script src="https://cdn.tailwindcss.com"></script>
        <script>
            // Tailwind Konfiguration für bessere Performance
            tailwind.config = {
                theme: {
                    extend: {
                        colors: {
                            primary: '#f97316',
                        }
                    }
                },
                corePlugins: {
                    preflight: true,
                }
            }
        </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --primary-color: #f97316;
            --primary-dark: #ea580c;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
        }
        
        body {
            font-family: 'Inter', sans-serif;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        .slide-up {
            animation: slideUp 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .device-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transition: all 0.3s ease;
        }
        
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .file-item {
            transition: all 0.3s ease;
        }
        
        .file-item:hover {
            background-color: rgba(255, 165, 0, 0.1);
        }
        
        .connection-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .connected {
            background-color: #10B981;
        }
        
        .disconnected {
            background-color: #EF4444;
        }
        
        .away {
            background-color: #F59E0B;
        }
        
        /* Logo Animation */
        @keyframes logoGlow {
            0% { 
                box-shadow: 0 0 5px rgba(249, 115, 22, 0.5);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 20px rgba(249, 115, 22, 0.8);
                transform: scale(1.02);
            }
            100% { 
                box-shadow: 0 0 5px rgba(249, 115, 22, 0.5);
                transform: scale(1);
            }
        }
        
        .logo-animation {
            animation: logoGlow 3s ease-in-out infinite;
        }
        
        /* Modern Upload Area */
        .upload-area {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(249, 115, 22, 0.3);
        }
        
        .upload-icon {
            transition: all 0.3s ease;
        }
        
        .upload-area:hover .upload-icon {
            transform: scale(1.1);
            color: #f97316;
        }
        
        /* Progress Bar */
        .progress-bar {
            transition: width 0.3s ease;
        }
        
        .progress-bar-indeterminate {
            background: linear-gradient(90deg, #f97316 0%, #fb923c 50%, #f97316 100%);
            background-size: 200% 100%;
            animation: progressIndeterminate 2s infinite linear;
        }
        
        @keyframes progressIndeterminate {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* Connection Strength */
        .connection-strength {
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .strength-bar {
            width: 3px;
            height: 8px;
            background-color: #d1d5db;
            border-radius: 1px;
            transition: all 0.3s ease;
        }
        
        .strength-bar.active {
            background-color: #10b981;
        }
        
        .strength-bar.good { background-color: #10b981; }
        .strength-bar.average { background-color: #f59e0b; }
        .strength-bar.poor { background-color: #ef4444; }
        
        /* File Type Badges */
        .file-type-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .file-type-image { background: #dbeafe; color: #1e40af; }
        .file-type-video { background: #fce7f3; color: #be185d; }
        .file-type-audio { background: #f0fdf4; color: #15803d; }
        .file-type-document { background: #fffbeb; color: #d97706; }
        .file-type-archive { background: #f3e8ff; color: #7e22ce; }
        .file-type-other { background: #f1f5f9; color: #475569; }
        
        /* Transfer Status */
        .transfer-status {
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        .receivedFilesCount {
            margin-left: 0.5rem !important; /* Statt ml-2 (0.5rem) */
            margin-right: auto !important; /* Pusht alles andere nach rechts */
        }

        /* Alternative: Noch weiter links */
        .receivedFilesCount.left-align {
            margin-left: 0.25rem !important;
            margin-right: auto !important;
        }

        /* Oder für maximale Links-Positionierung */
        .receivedFilesCount.far-left {
            margin-left: 0 !important;
            margin-right: 0.5rem !important;
            order: -1; /* Setzt das Badge ganz nach links */
        }

        /* Für die spezifische Überschrift-Struktur */
        .flex.items-center .receivedFilesCount {
            margin-left: 0.25rem !important;
            margin-right: auto !important;
        }
        
        .status-pending { background: #fef3c7; color: #d97706; }
        .status-transferring { background: #dbeafe; color: #1e40af; }
        .status-completed { background: #d1fae5; color: #065f46; }
        .status-error { background: #fee2e2; color: #dc2626; }
        .status-cancelled { background: #f3f4f6; color: #6b7280; }
        
        /* Dark Mode Styles */
        .dark {
            background: linear-gradient(135deg, #1a1b1f 0%, #2d2e32 100%);
            color: #e2e8f0;
        }

        .dark .bg-white {
            background: linear-gradient(145deg, #2a2b2f 0%, #35363a 100%);
            border: 1px solid #404247;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .dark .text-gray-800 {
            color: #f1f5f9;
        }

        .dark .text-gray-600, .dark .text-gray-500 {
            color: #94a3b8;
        }

        .dark .bg-gray-50 {
            background: linear-gradient(135deg, #2d2e32 0%, #37383d 100%);
            border: 1px solid #404247;
        }

        .dark .bg-gray-100 {
            background: linear-gradient(135deg, #2d2e32 0%, #3a3b40 100%);
        }

        .dark .bg-gray-200 {
            background: linear-gradient(135deg, #37383d 0%, #424348 100%);
        }

        .dark .border-gray-200 {
            border-color: #4a4b50;
        }

        .dark .border-gray-300 {
            border-color: #55565b;
        }

        .dark .shadow-md {
            box-shadow: 
                0 4px 6px -1px rgba(0, 0, 0, 0.3),
                0 2px 4px -1px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .dark .shadow-lg {
            box-shadow: 
                0 10px 15px -3px rgba(0, 0, 0, 0.4),
                0 4px 6px -2px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .dark .bg-orange-50 {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.15) 0%, rgba(234, 88, 12, 0.1) 100%);
            border: 1px solid rgba(251, 146, 60, 0.2);
        }

        .dark .border-orange-300 {
            border-color: rgba(251, 146, 60, 0.4);
        }

        /* Modern Card Styles */
        .dark .card-glass {
            background: linear-gradient(145deg, rgba(42, 43, 47, 0.9) 0%, rgba(53, 54, 58, 0.9) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        /* Upload Area Dark Mode */
        .dark .upload-area {
            background: linear-gradient(135deg, rgba(42, 43, 47, 0.8) 0%, rgba(53, 54, 58, 0.8) 100%);
            border: 2px dashed rgba(251, 146, 60, 0.3);
            backdrop-filter: blur(8px);
        }

        .dark .upload-area:hover {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.1) 0%, rgba(234, 88, 12, 0.05) 100%);
            border-color: rgba(251, 146, 60, 0.6);
            box-shadow: 
                0 0 30px rgba(251, 146, 60, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        /* Device Cards Dark Mode */
        .dark .device-card {
            background: linear-gradient(145deg, #2a2b2f 0%, #35363a 100%);
            border: 1px solid #404247;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .dark .device-card:hover {
            background: linear-gradient(145deg, #2d2e32 0%, #38393d 100%);
            border-color: #4a4b50;
            transform: translateY(-4px);
            box-shadow: 
                0 12px 24px rgba(0, 0, 0, 0.3),
                0 6px 12px rgba(0, 0, 0, 0.2);
        }

        /* Pinned Devices Dark Mode */
        .dark .pinned-device {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.1) 0%, rgba(234, 88, 12, 0.05) 100%);
            border: 2px solid rgba(251, 146, 60, 0.4);
            box-shadow: 
                0 8px 24px rgba(251, 146, 60, 0.15),
                inset 0 1px 0 rgba(251, 146, 60, 0.1);
        }

        /* Status Indicators */
        .dark .status-online {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .dark .status-offline {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            box-shadow: 0 2px 8px rgba(107, 114, 128, 0.3);
        }

        .dark .status-away {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }

        /* Buttons Dark Mode */
        .dark .btn-primary {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            border: 1px solid rgba(251, 146, 60, 0.3);
            box-shadow: 
                0 4px 12px rgba(249, 115, 22, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .dark .join {
            background-color: rgb(23 37 84 / 0.2);  /* dark:bg-blue-900/20 */
            border-color: rgb(29 78 216);           /* dark:border-blue-700 */
        }

        .dark .btn-primary:hover {
            background: linear-gradient(135deg, #fb923c 0%, #f97316 100%);
            box-shadow: 
                0 6px 16px rgba(249, 115, 22, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .dark .btn-secondary {
            background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
            border: 1px solid #4b5563;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .dark .btn-secondary:hover {
            background: linear-gradient(135deg, #4b5563 0%, #6b7280 100%);
            box-shadow: 
                0 6px 16px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        /* Progress Bar Dark Mode */
        .dark .progress-bg {
            background: #374151;
        }

        .dark .progress-fill {
            background: linear-gradient(90deg, #f97316, #fb923c);
        }

        /* Scrollbar Dark Mode */
        .dark ::-webkit-scrollbar {
            width: 8px;
        }

        .dark ::-webkit-scrollbar-track {
            background: #2d2e32;
            border-radius: 4px;
        }

        .dark ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #4b5563 0%, #6b7280 100%);
            border-radius: 4px;
        }

        .dark ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #6b7280 0%, #9ca3af 100%);
        }

        /* Platform-specific colors with dark mode adjustments */
        .dark .platform-windows { 
            color: #60a5fa; 
            text-shadow: 0 0 10px rgba(96, 165, 250, 0.3);
        }
        .dark .platform-macos { 
            color: #d1d5db; 
        }
        .dark .platform-linux { 
            color: #fbbf24; 
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.3);
        }
        .dark .platform-android { 
            color: #34d399; 
            text-shadow: 0 0 10px rgba(52, 211, 153, 0.3);
        }
        .dark .platform-ios { 
            color: #f87171; 
            text-shadow: 0 0 10px rgba(248, 113, 113, 0.3);
        }

        .dark .browser-chrome { 
            color: #60a5fa; 
        }
        .dark .browser-firefox { 
            color: #fb923c; 
        }
        .dark .browser-safari { 
            color: #fbbf24; 
        }
        .dark .browser-edge { 
            color: #60a5fa; 
        }
        .dark .browser-opera { 
            color: #f87171; 
        }

        .dark .RaumErstellen {
            color: rgb(249, 182, 60);
        }

        /* Edit name styles */
        .edit-name-input {
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .edit-name-input:focus {
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }

        .dark .edit-name-input {
            background: linear-gradient(135deg, #323337 0%, #3c3d42 100%);
            border: 2px solid #4a4b50;
            color: #f1f5f9;
        }

        .dark .edit-name-input:focus {
            border-color: rgba(251, 146, 60, 0.6);
            box-shadow: 0 0 0 3px rgba(251, 146, 60, 0.1);
            background: linear-gradient(135deg, #35363a 0%, #3f4045 100%);
        }

        .dark .RaumBeitreten {
            color: #9bd2ff;
        }

        /* Room Styles */
        .room-card {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .room-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px -5px rgba(249, 115, 22, 0.3);
        }

        .active-room {
            border: 2px solid #f97316;
            background: linear-gradient(135deg, #fff7ed 0%, #fffbeb 100%);
        }

        .dark .active-room {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.1) 0%, rgba(234, 88, 12, 0.05) 100%);
            border-color: rgba(251, 146, 60, 0.6);
        }

        /* Transfer Progress */
        .transfer-progress {
            transition: all 0.3s ease;
        }

        /* File Size Warning */
        .file-size-warning {
            border-left: 4px solid #f59e0b;
        }

        .dark .file-size-warning {
            border-left-color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        /* Memory Usage Indicator */
        .memory-usage {
            font-size: 0.75rem;
            padding: 4px 8px;
            border-radius: 12px;
            background: #f3f4f6;
            color: #6b7280;
        }

        .dark .memory-usage {
            background: #374151;
            color: #d1d5db;
        }

        .memory-usage.warning {
            background: #fef3c7;
            color: #d97706;
        }

        .dark .memory-usage.warning {
            background: rgba(245, 158, 11, 0.2);
            color: #fbbf24;
        }

        .memory-usage.critical {
            background: #fee2e2;
            color: #dc2626;
        }

        .dark .memory-usage.critical {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        /* Mobile Optimierungen */
        @media (max-width: 640px) {
            .mobile-padding {
                padding-left: 0.75rem;
                padding-right: 0.75rem;
            }

            .receivedFilesCount {
                margin-right: 1em;
            }
            
            .mobile-text-lg {
                font-size: 1rem;
            }
            
            .mobile-text-xl {
                font-size: 1.125rem;
            }
            
            .mobile-py-3 {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
            }
            
            .mobile-p-4 {
                padding: 0.75rem;
            }
            
            .mobile-space-y-4 > * + * {
                margin-top: 0.75rem;
            }
            
            .mobile-grid-cols-1 {
                grid-template-columns: 1fr;
            }

            /* Kompaktere Karten auf Mobile */
            .device-card {
                padding: 0.25rem;
            }

            .upload-area {
                padding: 1.5rem 1rem;
            }

            .upload-area .upload-icon {
                width: 16px;
                height: 16px;
            }

            .upload-area .upload-icon i {
                font-size: 1.5rem;
            }

            /* Kleinere Schrift in Karten */
            .file-item,
            .device-card,
            .room-card {
                font-size: 0.875rem;
            }

            /* Kompaktere Header */
            header .container {
                padding-top: 0.5rem;
                padding-bottom: 0.5rem;
            }

            /* Kleinere Buttons */
            .touch-button {
                min-height: 36px;
                min-width: 36px;
                font-size: 0.8rem;
                padding: 0.4rem 0.8rem;
            }

            /* Kompaktere Dateiliste */
            .file-item {
                padding: 0.6rem;
            }

            .file-item .w-10 {
                width: 8px;
                height: 8px;
            }

            /* Kleinere Icons */
            .text-3xl {
                font-size: 1.5rem;
            }

            .text-2xl {
                font-size: 1.25rem;
            }

            /* Kompaktere Modals */
            .modal {
                padding: 1rem;
                margin: 1rem;
            }

            /* Weniger Abstand zwischen Sektionen */
            main .py-6 {
                padding-top: 1rem;
                padding-bottom: 1rem;
            }

            section {
                margin-bottom: 0.75rem;
            }

            /* Kleinere Status-Badges */
            .server-status,
            .memory-usage,
            .room-badge {
                font-size: 0.7rem;
                padding: 0.2rem 0.5rem;
            }
        }
        
        /* Touch-friendly Buttons */
        .touch-button {
            min-height: 44px;
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Desktop/Laptop Optimierungen */
        @media (min-width: 1024px) {
            .container {
                max-width: 1200px;
                padding-left: 2rem;
                padding-right: 2rem;
            }
            
            .desktop-grid-cols-3 {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .desktop-p-6 {
                padding: 1.5rem;
            }
            
            .desktop-space-y-6 > * + * {
                margin-top: 1.5rem;
            }
        }
        
        /* Platform-specific colors */
        .platform-windows { color: #0078D4; }
        .platform-macos { color: #000000; }
        .platform-linux { color: #FF6600; }
        .platform-android { color: #3DDC84; }
        .platform-ios { color: #000000; }
        .platform-ipados { color: #000000; }
        .platform-unknown { color: #6B7280; }
        
        .browser-chrome { color: #4285F4; }
        .browser-firefox { color: #FF7139; }
        .browser-safari { color: #000000; }
        .browser-edge { color: #0078D7; }
        .browser-opera { color: #FF1B2D; }
        .browser-samsung { color: #1428A0; }
        .browser-unknown { color: #6B7280; }
        
        /* Pinned devices */
        .pinned-device {
            border: 2px solid #F59E0B;
            background: linear-gradient(135deg, #fff7ed 0%, #fffbeb 100%);
        }
        
        .dark .pinned-device {
            background: linear-gradient(135deg, #431407 0%, #451a03 100%);
            border-color: #D97706;
        }
        
        /* Online status badges */
        .status-online {
            background-color: #10B981;
            color: white;
        }
        
        .status-offline {
            background-color: #6B7280;
            color: white;
        }
        
        .status-away {
            background-color: #F59E0B;
            color: white;
        }

        /* Custom name badge */
        .custom-name-badge {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: white;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 4px;
        }

        /* Room badge */
        .room-badge {
            background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%);
            color: white;
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 12px;
        }

        /* Server Status */
        .server-status {
            font-size: 0.75rem;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        @keyframes successPulse {
            0% { 
                background: linear-gradient(90deg, #f97316, #fb923c);
                transform: scale(1);
            }
            50% { 
                background: linear-gradient(90deg, #10b981, #34d399);
                transform: scale(1.02);
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            }
            100% { 
                background: linear-gradient(90deg, #10b981, #34d399);
                transform: scale(1);
            }
        }

        .transfer-complete {
            animation: successPulse 1s ease-in-out;
            background: linear-gradient(90deg, #10b981, #34d399) !important;
        }

        .success-checkmark {
            display: inline-block;
            transform: scale(0);
            animation: checkmarkScale 0.3s ease-in-out 0.5s forwards;
        }

        @keyframes checkmarkScale {
            to {
                transform: scale(1);
            }
        }

        /* Verbunden-Animation */
        @keyframes connectedPulse {
            0% { 
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
            }
            50% { 
                transform: scale(1.1);
                box-shadow: 0 0 0 8px rgba(16, 185, 129, 0);
            }
            100% { 
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
            }
        }

        .connection-status.connected {
            animation: connectedPulse 2s infinite;
            box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
        }

        .dark .connection-status.connected {
            box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.7);
        }

        /* Mobile Download Button */
        #mobileDownloadBtn {
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
        }

        #mobileDownloadBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(249, 115, 22, 0.6);
        }

        .dark #mobileDownloadBtn {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.5);
        }


        /* Modern Toast System - Oben Mitte */
        #toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 
                0 20px 25px -5px rgba(0, 0, 0, 0.3),
                0 10px 10px -5px rgba(0, 0, 0, 0.2),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 90vw;
            width: auto;
            min-width: 280px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Toast Typen */
        .toast-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .toast-error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .toast-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .toast-info {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%) !important;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        /* Dark Mode Toast */
        .dark #toast {
            background: linear-gradient(135deg, #111827 0%, #1f2937 100%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        /* Toast Inhalt */
        #toast .flex {
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        #toastMessage {
            font-weight: 500;
            font-size: 0.95rem;
        }

        #toastIcon {
            font-size: 1.1rem;
        }

        /* Mobile Optimierung */
        @media (max-width: 640px) {
            #toast {
                top: 10px;
                padding: 14px 20px;
                min-width: 260px;
                max-width: 95vw;
            }
            
            #toastMessage {
                font-size: 0.9rem;
            }
            
            #toastIcon {
                font-size: 1rem;
            }
        }

        /* Animation für Toast-Icons */
        @keyframes toastIconBounce {
            0%, 20%, 53%, 80%, 100% {
                transform: scale(1);
            }
            40%, 43% {
                transform: scale(1.1);
            }
            70% {
                transform: scale(1.05);
            }
        }

        .toast-animate-icon {
            animation: toastIconBounce 1s ease;
        }

        /* Progress Bar für Toast */
        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, rgba(255,255,255,0.8), rgba(255,255,255,0.4));
            border-radius: 0 0 12px 12px;
            width: 100%;
            transform-origin: left;
            animation: toastProgress 4s linear forwards;
        }

        @keyframes toastProgress {
            from { transform: scaleX(1); }
            to { transform: scaleX(0); }
        }
    
        /* Modern Delete Button */
        .modern-delete-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 12px;
            font-weight: 500;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 12px rgba(239, 68, 68, 0.3),
                0 2px 4px rgba(239, 68, 68, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 44px;
        }

        .modern-delete-btn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-2px);
            box-shadow: 
                0 8px 20px rgba(239, 68, 68, 0.4),
                0 4px 8px rgba(239, 68, 68, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .modern-delete-btn:active {
            transform: translateY(0);
            box-shadow: 
                0 2px 8px rgba(239, 68, 68, 0.4),
                inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Ripple Effect */
        .modern-delete-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .modern-delete-btn:active::before {
            width: 100px;
            height: 100px;
        }

        /* Dark Mode */
        .dark .modern-delete-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 
                0 4px 12px rgba(239, 68, 68, 0.4),
                0 2px 4px rgba(239, 68, 68, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .dark .modern-delete-btn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            box-shadow: 
                0 8px 20px rgba(239, 68, 68, 0.5),
                0 4px 8px rgba(239, 68, 68, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        /* Icon Animation */
        .modern-delete-btn i {
            transition: transform 0.3s ease;
        }

        .modern-delete-btn:hover i {
            transform: scale(1.1) translateX(-1px);
        }

        .modern-delete-btn:active i {
            transform: scale(0.95);
        }

        /* Mobile Optimization */
        @media (max-width: 640px) {
            .modern-delete-btn {
                padding: 8px 16px;
                font-size: 0.8rem;
                min-height: 40px;
            }

            
            
            .modern-delete-btn span {
                font-size: 0.8rem;
            }
        }

        /* Loading State (optional) */
        .modern-delete-btn.loading {
            pointer-events: none;
            opacity: 0.8;
        }

        .modern-delete-btn.loading i {
            animation: trashShake 0.5s ease-in-out infinite;
        }

        @keyframes trashShake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }
        
        .server-online { background: #d1fae5; color: #065f46; }
        .server-offline { background: #fee2e2; color: #dc2626; }
        .server-warning { background: #fef3c7; color: #d97706; }

        .dark .server-online { background: rgba(16, 185, 129, 0.2); color: #34d399; }
        .dark .server-offline { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .dark .server-warning { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
    </style>
</head>
<body class="bg-gray-50 min-h-screen dark:bg-gray-800">
    <!-- Header -->
    <header class="bg-white shadow-sm dark:bg-white/5 dark:backdrop-blur-xl dark:border-b dark:border-white/10">
        <div class="container mx-auto mobile-padding py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <div class="w-10 h-10 bg-gradient-to-br from-orange-500 to-red-500 rounded-lg flex items-center justify-center logo-animation">
                    <i class="fas fa-share-nodes text-white text-lg"></i>
                </div>
                <div>
                    <h1 class="mobile-text-xl font-bold text-gray-800 dark:text-white">ETKn Share</h1>
                    <div class="flex items-center space-x-2 text-xs">
                        <span class="server-status server-online" id="serverStatus">Online</span>
                    </div>
                </div>
                <div id="connectionStatus" class="hidden md:flex items-center ml-4 text-sm">
                    <span class="connection-status disconnected" id="statusIndicator"></span>
                    <span id="statusText" class="dark:text-gray-300">Verbinden...</span>
                    <div id="roomDeviceHeader" class="ml-3 room-badge text-xs hidden">
                        <i class="fas fa-users mr-1"></i>
                        <span id="headerDeviceCount">0</span> Geräte
                    </div>
                </div>
            </div>
            <div class="flex space-x-2">
                <div id="roomInfo" class="hidden items-center space-x-2">
                    <button id="leaveRoomBtn" class="bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded-lg transition duration-300 touch-button text-sm">
                        <i class="fas fa-sign-out-alt mr-1"></i>
                        <span id="currentRoomName" class="hidden sm:inline">Verlassen</span>
                    </button>
                </div>
                <button id="themeToggle" class="bg-gray-200 hover:bg-gray-300 text-gray-800 w-10 h-10 rounded-full flex items-center justify-center transition duration-300 touch-button dark:btn-secondary">
                    <i class="fas fa-moon text-sm"></i>
                </button>
            </div>
        </div>
        
        <!-- Mobile Connection Status -->
        <div class="md:hidden mobile-padding py-2 border-t border-gray-100 dark:border-gray-600">
            <div class="flex items-center justify-between">
                <div id="mobileConnectionStatus" class="flex items-center text-sm">
                    <span class="connection-status disconnected" id="mobileStatusIndicator"></span>
                    <span id="mobileStatusText" class="dark:text-gray-300">Verbinden...</span>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="server-status server-online text-xs" id="mobileServerStatus">Online</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto mobile-padding py-6 mobile-space-y-4 desktop-space-y-6">
        <!-- Room Section -->
        <section id="roomSection" class="bg-white rounded-xl shadow-md mobile-p-4 desktop-p-6 slide-up dark:card-glass">
            <h2 class="mobile-text-xl font-bold text-gray-800 dark:text-white mb-4 flex items-center">
                <i class="fas fa-door-open text-orange-500 mr-3"></i>
                Raum beitreten oder erstellen
            </h2>
            
            <div class="grid mobile-grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <div class="bg-orange-50 border border-orange-200 rounded-xl p-4 dark:bg-orange-900/20 dark:border-orange-700">
                    <h3 class="RaumErstellen font-semibold text-orange-800 dark:text-orange-200 mb-2 flex items-center">
                        <i class="fas fa-plus-circle mr-2"></i>
                        Neuen Raum erstellen
                    </h3>
                    <p class="RaumErstellen text-sm text-orange-600 dark:text-orange-300 mb-3">Erstelle einen neuen Raum und lade andere ein beizutreten</p>
                    <div class="space-y-2">
                        <input type="text" id="createRoomName" placeholder="Raumname (z.B. Büro)" class="w-full px-3 py-2 border border-orange-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent dark:bg-gray-700 dark:border-orange-500 dark:text-white">
                        <button id="createRoomBtn" class="w-full bg-orange-500 hover:bg-orange-600 text-white px-4 py-3 rounded-lg transition duration-300 touch-button">
                            <i class="fas fa-plus mr-2"></i>Raum erstellen
                        </button>
                    </div>
                </div>
                
                <div id="join" class="join bg-blue-50 border border-blue-200 rounded-xl p-4 dark:bg-blue-950/30 dark:border-blue-800">
                    <h3 class="RaumBeitreten font-semibold text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                        <i class="fas fa-sign-in-alt mr-2"></i>
                        Raum beitreten
                    </h3>
                    <p class="RaumBeitreten text-sm text-blue-600 dark:text-blue-300 mb-3">Trete einem bestehenden Raum bei, um Dateien zu teilen</p>
                    <div class="space-y-2">
                        <input type="text" id="joinRoomName" placeholder="Raumname eingeben" class="w-full px-3 py-2 border border-blue-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-blue-800/30 dark:border-blue-600 dark:text-white dark:placeholder-blue-300">
                        <button id="joinRoomBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-3 rounded-lg transition duration-300 touch-button dark:bg-blue-700 dark:hover:bg-blue-600">
                            <i class="fas fa-sign-in-alt mr-2"></i>Raum beitreten
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="text-center text-gray-500 dark:text-gray-400">
                <i class="fas fa-users text-2xl mb-2"></i>
                <p class="text-sm">Wähle einen Raum, um Geräte zu sehen und Dateien zu teilen</p>
            </div>
        </section>

        <!-- Upload Section -->
        <section id="uploadSection" class="bg-white rounded-xl shadow-md mobile-p-4 desktop-p-6 slide-up dark:card-glass hidden">
            <h2 class="mobile-text-xl font-bold text-gray-800 dark:text-white mb-4 flex items-center">
                <i class="fas fa-cloud-upload-alt text-orange-500 mr-3"></i>
                Daten hochladen
                <span id="selectedFilesCount" class="ml-2 bg-orange-100 text-orange-800 text-xs font-medium px-2 py-1 rounded-full dark:bg-orange-900 dark:text-orange-200 hidden">0</span>
            </h2>
            
            <div id="uploadArea" class="upload-area border-2 border-dashed border-orange-300 rounded-xl p-8 text-center mb-4 transition duration-300 bg-gradient-to-br from-orange-50 to-red-50 dark:upload-area">
                <div class="upload-icon w-20 h-20 mx-auto mb-4 bg-white rounded-full flex items-center justify-center shadow-lg dark:bg-gray-500">
                    <i class="fas fa-cloud-upload-alt text-3xl text-orange-500"></i>
                </div>
                <p class="text-gray-600 dark:text-gray-300 mb-2 text-sm font-medium">Dateien hierher ziehen oder klicken zum Auswählen</p>
                <p class="text-gray-500 dark:text-gray-400 mb-2 text-xs">Max. 500MB pro Datei, alle gängigen Dateitypen</p>
                <p class="text-orange-500 text-xs font-medium">Unterstützt große Dateien mit Fortschrittsanzeige</p>
                <input type="file" id="fileInput" class="hidden" multiple>
            </div>
            
            <!-- File Size Warning -->
            <div id="fileSizeWarning" class="file-size-warning bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-4 hidden dark:file-size-warning">
                <div class="flex items-center">
                    <i class="fas fa-exclamation-triangle text-yellow-500 mr-2"></i>
                    <p class="text-yellow-800 text-sm dark:text-yellow-200">
                        <span id="largeFileCount">0 große Dateien</span> ausgewählt. Die Übertragung kann länger dauern.
                    </p>
                </div>
            </div>
            
            <div id="fileList" class="space-y-3 hidden">
                <h3 class="text-base font-semibold text-gray-700 dark:text-gray-300 mb-2">Ausgewählte Dateien:</h3>
                <div id="fileListContainer" class="space-y-2 max-h-64 overflow-y-auto">
                    <!-- Files will be added here dynamically -->
                </div>
                <div class="flex justify-between items-center pt-2 border-t border-gray-200 dark:border-gray-600">
                    <span class="text-sm text-gray-500 dark:text-gray-400">
                        Gesamt: <span id="totalFileSize">0 Bytes</span>
                    </span>
                    <button id="clearFiles" class="text-red-500 hover:text-red-700 text-sm font-medium touch-button">
                        <i class="fas fa-times mr-1"></i>Alle entfernen
                    </button>
                </div>
            </div>

            <!-- Active Transfers -->
            <div id="activeTransfers" class="mt-6 hidden">
                <h3 class="text-base font-semibold text-gray-700 dark:text-gray-300 mb-3">Aktive Übertragungen:</h3>
                <div id="transfersList" class="space-y-3">
                    <!-- Transfer progress will be shown here -->
                </div>
            </div>
        </section>
        
        <!-- Available Devices Section -->
        <section id="devicesSection" class="bg-white rounded-xl shadow-md mobile-p-4 desktop-p-6 slide-up dark:card-glass hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="mobile-text-xl font-bold text-gray-800 dark:text-white flex items-center">
                    <i class="fas fa-laptop text-orange-500 mr-3"></i>
                    Geräte im Raum
                    <span id="devicesCount" class="ml-2 bg-orange-100 text-orange-800 text-xs font-medium px-2 py-1 rounded-full dark:bg-orange-900 dark:text-orange-200">0</span>
                </h2>
                <div class="flex space-x-2">
                    <button id="refreshDevices" class="bg-gray-200 hover:bg-gray-400 text-white-700 px-3 py-2 rounded-lg transition duration-300 touch-button text-sm dark:btn-secondary">
                        <i class="fas fa-sync-alt mr-1"></i><span class="hidden sm:inline">Aktualisieren</span>
                    </button>
                </div>
            </div>
            
            <div class="flex flex-wrap gap-2 mb-4">
                <span class="status-online text-xs px-2 py-1 rounded-full">Online</span>
                <span class="bg-yellow-500 text-white text-xs px-2 py-1 rounded-full">Angepinnt</span>

            </div>
            
            <div id="devicesList" class="grid mobile-grid-cols-1 md:grid-cols-2 desktop-grid-cols-3 gap-3">
                <div class="text-center py-6 text-gray-500 dark:text-gray-400">
                    <i class="fas fa-search text-2xl mb-2"></i>
                    <p class="text-sm">Suche nach Geräten im Raum...</p>
                </div>
            </div>
        </section>
        
        <!-- Received Files Section -->
        <section id="receivedSection" class="bg-white rounded-xl shadow-md mobile-p-4 desktop-p-6 slide-up dark:card-glass hidden">
            <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-4 gap-4 sm:gap-0">
                <h2 class="mobile-text-xl font-bold text-gray-800 dark:text-white flex items-center justify-center sm:justify-start">
                    <i class="fas fa-download text-orange-500 mr-3"></i>
                    Empfangene Dateien
                    <span id="receivedFilesCount" class="ml-2 bg-green-100 text-green-800 text-xs font-medium px-2 py-1 rounded-full dark:bg-green-900 dark:text-green-200">0</span>
                </h2>
                <button id="clearReceived" class="modern-delete-btn touch-button w-full sm:w-auto">
                    <i class="fas fa-trash mr-2"></i>
                    <span>Alle löschen</span>
                </button>
            </div>
            
            <div id="receivedFiles" class="space-y-3">
                <div class="text-center py-8 text-gray-500 dark:text-gray-400">
                    <i class="fas fa-inbox text-3xl mb-3"></i>
                    <p class="text-sm">Noch keine empfangenen Dateien</p>
                    <p class="text-xs mt-1">Akzeptierte Dateien erscheinen hier</p>
                </div>
            </div>
        </section>
    </main>

    <!-- Incoming Files Modal -->
    <div id="incomingFilesModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden fade-in mobile-padding">
        <div class="bg-white rounded-xl p-4 w-full max-w-md mx-auto dark:modal">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-bold text-gray-800 dark:text-white">Eingehende Dateien</h3>
                <button id="closeIncomingModal" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-white touch-button">
                    <i class="fas fa-times text-lg"></i>
                </button>
            </div>
            
            <div class="mb-4">
                <p id="incomingFrom" class="text-gray-600 dark:text-gray-300 mb-3 text-sm"></p>
                <div class="flex items-center justify-between mb-2">
                    <span class="text-sm text-gray-500 dark:text-gray-400">Gesamtgröße:</span>
                    <span id="incomingTotalSize" class="text-sm font-medium text-gray-700 dark:text-gray-300">Berechne...</span>
                </div>
                <div id="incomingFilesList" class="space-y-2 max-h-60 overflow-y-auto">
                </div>
            </div>
            
            <div class="flex space-x-3">
                <button id="rejectFiles" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-3 rounded-lg transition duration-300 touch-button dark:btn-secondary">
                    Ablehnen
                </button>
                <button id="acceptFiles" class="flex-1 bg-orange-500 hover:bg-orange-600 text-white px-4 py-3 rounded-lg transition duration-300 touch-button dark:btn-primary">
                    Akzeptieren
                </button>
            </div>
        </div>
    </div>

    <!-- Edit Name Modal -->
    <div id="editNameModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden fade-in mobile-padding">
        <div class="bg-white rounded-xl p-4 w-full max-w-md mx-auto dark:modal">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-bold text-gray-800 dark:text-white">Gerätenamen bearbeiten</h3>
                <button id="closeEditNameModal" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-white touch-button">
                    <i class="fas fa-times text-lg"></i>
                </button>
            </div>
            
            <div class="mb-4">
                <p class="text-gray-600 dark:text-gray-300 mb-3 text-sm">Vergeben Sie einen benutzerdefinierten Namen für dieses Gerät:</p>
                <div class="space-y-2">
                    <div class="flex items-center space-x-2 text-sm text-gray-500 dark:text-gray-400">
                        <i class="fas fa-desktop" id="editDeviceIcon"></i>
                        <span id="editDeviceOriginal"></span>
                    </div>
                    <input type="text" id="editNameInput" placeholder="Mein Gerätename" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent edit-name-input">
                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Dieser Name wird nur auf diesem Gerät gespeichert</p>
                </div>
            </div>
            
            <div class="flex space-x-3">
                <button id="cancelEditName" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-3 rounded-lg transition duration-300 touch-button dark:btn-secondary">
                    Abbrechen
                </button>
                <button id="saveEditName" class="flex-1 bg-orange-500 hover:bg-orange-600 text-white px-4 py-3 rounded-lg transition duration-300 touch-button dark:btn-primary">
                    Speichern
                </button>
            </div>
        </div>
    </div>

    <!-- Transfer Progress Modal -->
    <div id="transferProgressModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden fade-in mobile-padding">
        <div class="bg-white rounded-xl p-4 w-full max-w-md mx-auto dark:modal">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-bold text-gray-800 dark:text-white" id="transferProgressTitle">Übertragung läuft...</h3>
                <button id="cancelTransfer" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-white touch-button">
                    <i class="fas fa-times text-lg"></i>
                </button>
            </div>
            
            <div class="mb-4">
                <div class="flex justify-between text-sm text-gray-600 dark:text-gray-300 mb-2">
                    <span id="transferFileName">Datei</span>
                    <span id="transferFileProgress">0%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2 dark:bg-gray-700">
                    <div id="transferProgressBar" class="progress-fill h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-1">
                    <span id="transferSpeed">Geschwindigkeit: Berechne...</span>
                    <span id="transferTime">Verbleibend: Berechne...</span>
                </div>
            </div>
            
            <div class="text-center">
                <button id="pauseTransfer" class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg transition duration-300 touch-button text-sm">
                    <i class="fas fa-pause mr-1"></i>Pausieren
                </button>
            </div>
        </div>
    </div>

    <!-- Server Info Modal -->
    <div id="serverInfoModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden fade-in mobile-padding">
        <div class="bg-white rounded-xl p-4 w-full max-w-md mx-auto dark:modal">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-bold text-gray-800 dark:text-white">Server-Informationen</h3>
                <button id="closeServerInfo" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-white touch-button">
                    <i class="fas fa-times text-lg"></i>
                </button>
            </div>
            
            <div class="space-y-3 text-sm">
                <div class="flex justify-between">
                    <span class="text-gray-600 dark:text-gray-300">Status:</span>
                    <span id="serverStatusInfo" class="font-medium">Online</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600 dark:text-gray-300">Verbindungen:</span>
                    <span id="serverConnections" class="font-medium">0</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600 dark:text-gray-300">Räume:</span>
                    <span id="serverRooms" class="font-medium">0</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600 dark:text-gray-300">Aktive Transfers:</span>
                    <span id="serverTransfers" class="font-medium">0</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600 dark:text-gray-300">Memory Usage:</span>
                    <span id="serverMemory" class="font-medium">0 MB</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600 dark:text-gray-300">Uptime:</span>
                    <span id="serverUptime" class="font-medium">0s</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600 dark:text-gray-300">Max. Dateigröße:</span>
                    <span class="font-medium">500MB</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600 dark:text-gray-300">Chunk-Größe:</span>
                    <span class="font-medium">1MB</span>
                </div>
            </div>
            
            <div class="mt-4 text-center">
                <button id="refreshServerInfo" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition duration-300 touch-button text-sm">
                    <i class="fas fa-sync-alt mr-1"></i>Aktualisieren
                </button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast hidden">
        <div class="flex items-center">
            <i class="fas fa-info-circle text-blue-300 mr-2" id="toastIcon"></i>
            <span id="toastMessage" class="text-sm font-medium">Erfolgreich!</span>
        </div>
    </div>

    <div id="mobileDownloadBtn" class="fixed bottom-6 right-6 bg-orange-500 text-white p-4 rounded-full shadow-lg touch-button z-40 md:hidden pulse-animation">
        <i class="fas fa-download text-xl"></i>
        <span id="mobileDownloadBadge" class="absolute -top-1 -right-1 bg-red-500 text-white rounded-full text-xs w-5 h-5 flex items-center justify-center hidden">0</span>
    </div>

<script>
    // Erweiterte WebSocket-Verbindung und Geräteverwaltung
    let ws = null;
    let currentDeviceId = null;
    let selectedFiles = [];
    let receivedFilesData = new Map();
    let activeTransfers = new Map();
    let transferHistory = JSON.parse(localStorage.getItem('transferHistory') || '[]');
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    let reconnectDelay = 1000;
    let customDeviceNames = JSON.parse(localStorage.getItem('customDeviceNames') || '{}');
    let currentRoom = null;
    let serverInfo = {};
    
    // Erweiterte Variablen für Dateiverwaltung
    let pendingIncomingFiles = null;
    let fileDataStorage = new Map();
    let currentEditingDevice = null;
    let currentTransfer = null;
    let transferStartTime = null;
    let chunkSize = 20 * 1024 * 1024; // 20MB Chunks

    
    // Performance Monitoring
    let connectionStats = {
        messagesSent: 0,
        messagesReceived: 0,
        bytesSent: 0,
        bytesReceived: 0,
        lastPing: 0,
        connectionStrength: 'good'
    };
    
    // DOM-Elemente
    const fileInput = document.getElementById('fileInput');
    const uploadArea = document.getElementById('uploadArea');
    const fileList = document.getElementById('fileList');
    const fileListContainer = document.getElementById('fileListContainer');
    const devicesList = document.getElementById('devicesList');
    const refreshDevices = document.getElementById('refreshDevices');
    const receivedSection = document.getElementById('receivedSection');
    const receivedFiles = document.getElementById('receivedFiles');
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    const toastIcon = document.getElementById('toastIcon');
    const themeToggle = document.getElementById('themeToggle');
    const connectionStatus = document.getElementById('connectionStatus');
    const statusIndicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('statusText');
    const mobileConnectionStatus = document.getElementById('mobileConnectionStatus');
    const mobileStatusIndicator = document.getElementById('mobileStatusIndicator');
    const mobileStatusText = document.getElementById('mobileStatusText');
    const devicesCount = document.getElementById('devicesCount');
    const selectedFilesCount = document.getElementById('selectedFilesCount');
    const totalFileSize = document.getElementById('totalFileSize');
    const clearFiles = document.getElementById('clearFiles');
    const fileSizeWarning = document.getElementById('fileSizeWarning');
    const largeFileCount = document.getElementById('largeFileCount');
    const activeTransfersSection = document.getElementById('activeTransfers');
    const transfersList = document.getElementById('transfersList');
    const receivedFilesCount = document.getElementById('receivedFilesCount');
    const clearReceived = document.getElementById('clearReceived');
    const serverStatus = document.getElementById('serverStatus');
    const mobileServerStatus = document.getElementById('mobileServerStatus');
    const memoryUsage = document.getElementById('memoryUsage');
    const mobileMemoryUsage = document.getElementById('mobileMemoryUsage');
    const roomDeviceCount = document.getElementById('roomDeviceCount');
    
    // Room Elements
    const roomSection = document.getElementById('roomSection');
    const uploadSection = document.getElementById('uploadSection');
    const devicesSection = document.getElementById('devicesSection');
    const createRoomName = document.getElementById('createRoomName');
    const createRoomBtn = document.getElementById('createRoomBtn');
    const joinRoomName = document.getElementById('joinRoomName');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const roomInfo = document.getElementById('roomInfo');
    const currentRoomName = document.getElementById('currentRoomName');
    const leaveRoomBtn = document.getElementById('leaveRoomBtn');
    
    // Modal Elements
    const incomingFilesModal = document.getElementById('incomingFilesModal');
    const closeIncomingModal = document.getElementById('closeIncomingModal');
    const incomingFrom = document.getElementById('incomingFrom');
    const incomingTotalSize = document.getElementById('incomingTotalSize');
    const incomingFilesList = document.getElementById('incomingFilesList');
    const rejectFiles = document.getElementById('rejectFiles');
    const acceptFiles = document.getElementById('acceptFiles');
    
    const editNameModal = document.getElementById('editNameModal');
    const closeEditNameModal = document.getElementById('closeEditNameModal');
    const editDeviceIcon = document.getElementById('editDeviceIcon');
    const editDeviceOriginal = document.getElementById('editDeviceOriginal');
    const editNameInput = document.getElementById('editNameInput');
    const cancelEditName = document.getElementById('cancelEditName');
    const saveEditName = document.getElementById('saveEditName');
    
    const transferProgressModal = document.getElementById('transferProgressModal');
    const transferProgressTitle = document.getElementById('transferProgressTitle');
    const transferFileName = document.getElementById('transferFileName');
    const transferFileProgress = document.getElementById('transferFileProgress');
    const transferProgressBar = document.getElementById('transferProgressBar');
    const transferSpeed = document.getElementById('transferSpeed');
    const transferTime = document.getElementById('transferTime');
    const cancelTransfer = document.getElementById('cancelTransfer');
    const pauseTransfer = document.getElementById('pauseTransfer');
    
    const serverInfoModal = document.getElementById('serverInfoModal');
    const closeServerInfo = document.getElementById('closeServerInfo');
    const serverStatusInfo = document.getElementById('serverStatusInfo');
    const serverConnections = document.getElementById('serverConnections');
    const serverRooms = document.getElementById('serverRooms');
    const serverTransfers = document.getElementById('serverTransfers');
    const serverMemory = document.getElementById('serverMemory');
    const serverUptime = document.getElementById('serverUptime');
    const refreshServerInfo = document.getElementById('refreshServerInfo');

    const mobileDownloadBtn = document.getElementById('mobileDownloadBtn');
    const mobileDownloadBadge = document.getElementById('mobileDownloadBadge');
    const roomDeviceHeader = document.getElementById('roomDeviceHeader');
    const headerDeviceCount = document.getElementById('headerDeviceCount');
    
    // Event-Listener
    document.addEventListener('DOMContentLoaded', init);
    uploadArea.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileSelect);
    uploadArea.addEventListener('dragover', handleDragOver);
    uploadArea.addEventListener('drop', handleFileDrop);
    refreshDevices.addEventListener('click', refreshAvailableDevices);
    themeToggle.addEventListener('click', toggleTheme);
    createRoomBtn.addEventListener('click', createRoom);
    joinRoomBtn.addEventListener('click', joinRoom);
    leaveRoomBtn.addEventListener('click', leaveRoom);
    clearFiles.addEventListener('click', clearAllFiles);
    clearReceived.addEventListener('click', clearAllReceivedFiles);
    mobileDownloadBtn.addEventListener('click', showReceivedFiles);
    
    // Enter-Taste für Raum-Eingaben
    createRoomName.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') createRoom();
    });
    
    joinRoomName.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') joinRoom();
    });
    
    // Modal Event-Listener
    closeIncomingModal.addEventListener('click', () => incomingFilesModal.classList.add('hidden'));
    rejectFiles.addEventListener('click', rejectIncomingFiles);
    acceptFiles.addEventListener('click', acceptIncomingFiles);
    
    closeEditNameModal.addEventListener('click', () => editNameModal.classList.add('hidden'));
    cancelEditName.addEventListener('click', () => editNameModal.classList.add('hidden'));
    saveEditName.addEventListener('click', saveDeviceName);
    editNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') saveDeviceName();
    });
    
    cancelTransfer.addEventListener('click', cancelCurrentTransfer);
    pauseTransfer.addEventListener('click', togglePauseTransfer);
    closeServerInfo.addEventListener('click', () => serverInfoModal.classList.add('hidden'));
    refreshServerInfo.addEventListener('click', fetchServerInfo);
    
    // Klicks außerhalb der Modals schließen diese
    incomingFilesModal.addEventListener('click', (e) => {
        if (e.target === incomingFilesModal) incomingFilesModal.classList.add('hidden');
    });
    
    editNameModal.addEventListener('click', (e) => {
        if (e.target === editNameModal) editNameModal.classList.add('hidden');
    });
    
    transferProgressModal.addEventListener('click', (e) => {
        if (e.target === transferProgressModal) transferProgressModal.classList.add('hidden');
    });
    
    serverInfoModal.addEventListener('click', (e) => {
        if (e.target === serverInfoModal) serverInfoModal.classList.add('hidden');
    });

    // Server-Info Modal Event-Listener
    serverStatus.addEventListener('click', showServerInfoModal);
    mobileServerStatus.addEventListener('click', showServerInfoModal);
    

    function setupChunkMonitoring() {
        let chunkStats = {
            totalChunks: 0,
            receivedChunks: 0,
            missingChunks: [],
            lastChunkTime: Date.now()
        };
        
        // Überwache Chunk-Empfang
        setInterval(() => {
            const now = Date.now();
            const timeSinceLastChunk = now - chunkStats.lastChunkTime;
            
            // Wenn länger als 5 Sekunden kein Chunk empfangen wurde
            if (timeSinceLastChunk > 5000 && chunkStats.receivedChunks > 0 && chunkStats.receivedChunks < chunkStats.totalChunks) {
                console.warn('⚠️ Möglicher Chunk-Verlust - letzter Chunk vor', timeSinceLastChunk + 'ms');
                
                // Frage fehlende Chunks nach
                if (ws && ws.readyState === WebSocket.OPEN && currentTransfer) {
                    ws.send(JSON.stringify({
                        type: 'requestMissingChunks',
                        transferId: currentTransfer.id,
                        receivedChunks: chunkStats.receivedChunks,
                        totalChunks: chunkStats.totalChunks
                    }));
                    
                    showToast('🔄 Frage fehlende Daten an...', 'warning');
                }
            }
        }, 2000);
    }

    let toastQueue = [];
    let isToastShowing = false;

    function queueToast(message, type = 'info') {
        toastQueue.push({ message, type });
        if (!isToastShowing) {
            showNextToast();
        }
    }

    function showNextToast() {
        if (toastQueue.length === 0) {
            isToastShowing = false;
            return;
        }
        
        isToastShowing = true;
        const { message, type } = toastQueue.shift();
        showToast(message, type);
        
        // Zeige nächsten Toast nach einer Verzögerung
        setTimeout(showNextToast, 4500);
    }


    function setupChunkMonitoring() {
        let chunkStats = {
            totalChunks: 0,
            receivedChunks: 0,
            missingChunks: [],
            lastChunkTime: Date.now()
        };
        
        // Überwache Chunk-Empfang
        setInterval(() => {
            const now = Date.now();
            const timeSinceLastChunk = now - chunkStats.lastChunkTime;
            
            // Wenn länger als 5 Sekunden kein Chunk empfangen wurde
            if (timeSinceLastChunk > 5000 && chunkStats.receivedChunks > 0 && chunkStats.receivedChunks < chunkStats.totalChunks) {
                console.warn('⚠️ Möglicher Chunk-Verlust - letzter Chunk vor', timeSinceLastChunk + 'ms');
                
                // Frage fehlende Chunks nach
                if (ws && ws.readyState === WebSocket.OPEN && currentTransfer) {
                    const missingChunks = [];
                    for (let i = 0; i < chunkStats.totalChunks; i++) {
                        if (!chunkStats.receivedChunks[i]) {
                            missingChunks.push(i);
                        }
                    }
                    
                    if (missingChunks.length > 0) {
                        ws.send(JSON.stringify({
                            type: 'requestMissingChunks',
                            transferId: currentTransfer.id,
                            missingChunks: missingChunks,
                            totalChunks: chunkStats.totalChunks
                        }));
                        
                        showToast('🔄 Frage fehlende Daten an...', 'warning');
                    }
                }
            }
        }, 2000);
    }

    function getBrowserInfo() {
        const ua = navigator.userAgent;
        let browser = 'Unknown';
        let version = 'Unknown';
        
        // Chrome
        if (ua.includes('Chrome') && !ua.includes('Edg')) {
            browser = 'Chrome';
            version = ua.match(/Chrome\/([0-9.]+)/)?.[1] || 'Unknown';
        }
        // Safari
        else if (ua.includes('Safari') && !ua.includes('Chrome')) {
            browser = 'Safari';
            version = ua.match(/Version\/([0-9.]+)/)?.[1] || 'Unknown';
        }
        // Firefox
        else if (ua.includes('Firefox')) {
            browser = 'Firefox';
            version = ua.match(/Firefox\/([0-9.]+)/)?.[1] || 'Unknown';
        }
        // Edge
        else if (ua.includes('Edg')) {
            browser = 'Edge';
            version = ua.match(/Edg\/([0-9.]+)/)?.[1] || 'Unknown';
        }
        
        return { browser, version };
    }

    // Füge diese Funktion hinzu (am besten in der init() Funktion oder direkt danach)
    function setupPageReloadReconnect() {
        // Prüfe ob die Seite gerade neu geladen wurde
        const isPageReload = performance.navigation.type === 1 || 
                            performance.getEntriesByType('navigation')[0]?.type === 'reload';
        
        if (isPageReload) {
            console.log('🔄 Seite neu geladen - starte Reconnect-Test');
            
            // Verzögere den Reconnect um 500ms um dem Browser Zeit zu geben
            setTimeout(() => {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    console.log('🔌 Starte Reconnect nach Neuladen');
                    reconnectAttempts = 0;
                    connectWebSocket();
                    
                    // Zeige speziellen Toast für Neuladen
                    showToast('🔄 Stelle Verbindung nach Neuladen her...', 'info');
                }
            }, 500);
        }
    }

    // ODER verwende das load Event für zuverlässigere Erkennung
    function setupLoadReconnect() {
        window.addEventListener('load', function() {
            console.log('📄 Seite vollständig geladen - prüfe Verbindung');
            
            // Kurze Verzögerung für bessere Stabilität
            setTimeout(() => {
                const isReload = performance.navigation?.type === 1 || 
                            window.performance?.getEntriesByType('navigation')[0]?.type === 'reload';
                
                if (isReload) {
                    console.log('🔄 Erkannt als Seiten-Neuladen - starte Reconnect');
                    
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        reconnectAttempts = 0;
                        connectWebSocket();
                        showToast('🔌 Verbindung wird nach Neuladen wiederhergestellt', 'info');
                    }
                }
            }, 1000);
        });
    }

    // ODER die einfachste Lösung - direkt in init() nach connectWebSocket()
    function setupReloadDetection() {
        // Prüfe ob Performance API verfügbar ist
        if (window.performance) {
            const navEntry = performance.getEntriesByType('navigation')[0];
            if (navEntry && (navEntry.type === 'reload' || navEntry.type === 'navigate')) {
                console.log('🔄 Seiten-Neuladen erkannt - aktiviere erweiterten Reconnect');
                
                // Setze spezielle Flags für Neuladen
                connectionStats.isReload = true;
                
                // Starte erweiterten Reconnect-Versuch
                setTimeout(() => {
                    if (!ws || ws.readyState === WebSocket.CLOSED) {
                        console.log('🚀 Starte erweiterten Reconnect nach Neuladen');
                        reconnectAttempts = 0;
                        connectWebSocket();
                    }
                }, 800);
            }
        }
    }


    function init() {
        console.log('🚀 Initialisiere ETKn Share mit verbessertem Verbindungsmanagement');
        
        const browserInfo = getBrowserInfo();
        console.log(`🌐 Browser: ${browserInfo.browser} ${browserInfo.version}`);
        
        // Safari-Optimierung aktivieren
        optimizeForSafari();
        loadSavedTheme();
        
        // Netzwerk-Monitoring starten
        setupNetworkMonitoring();
        
        // Erste Verbindung herstellen
        connectWebSocket();
        
        // 🔥 HIER EINFÜGEN: Reconnect nach Neuladen
        setupReloadDetection();
        
        // Regelmäßige Verbindungsüberwachung
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                updateConnectionQuality();
                
                if (connectionStats.connectionStrength === 'poor' && 
                    connectionStats.lastMessageTime && 
                    (Date.now() - connectionStats.lastMessageTime) > 30000) {
                    console.warn('⚠️ Schlechte Verbindung - starte Reconnect');
                    reconnectAttempts = 0;
                    connectWebSocket();
                }
            }
        }, 30000);
    }

    // Alternative: Noch einfachere Lösung - direkt nach DOMContentLoaded
    document.addEventListener('DOMContentLoaded', function() {
        // Prüfe sofort ob es ein Neuladen war
        if (performance.navigation && performance.navigation.type === 1) {
            console.log('🔄 Seiten-Neuladen erkannt - starte Reconnect-Test');
            
            // Setze Timeout um sicherzustellen dass DOM bereit ist
            setTimeout(() => {
                if (!window.ws || window.ws.readyState !== WebSocket.OPEN) {
                    console.log('🔌 Starte automatischen Reconnect nach Neuladen');
                    window.reconnectAttempts = 0;
                    
                    // Zeige sofortigen Status
                    updateConnectionStatus(false, 'Stelle Verbindung her...');
                    showToast('🔄 Stelle Verbindung nach Neuladen her', 'info');
                    
                    // Starte Verbindung
                    connectWebSocket();
                }
            }, 300);
        }
    });

    function shouldOptimizeForSafari() {
        const ua = navigator.userAgent;
        const isIOS = /iPhone|iPad|iPod/.test(ua);
        const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
        
        return isIOS && isSafari;
    }

    
    // Verbesserte WebSocket-Verbindung mit Client-ID und Verbindungsmanagement
    function connectWebSocket() {
        const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        
        if (isIOS && isSafari) {
            console.log('🍎 iOS Safari erkannt - aktiviere optimierten Modus');
            // Kein Return mehr - Verbindung wird normal aufgebaut
        }

        // Vorherige Verbindung sauber schließen
        if (ws && ws.readyState !== WebSocket.CLOSED) {
            console.log('🔄 Schließe vorherige Verbindung für neuen Verbindungsversuch');
            ws.onclose = null;
            ws.close(1000, "Neue Verbindung wird aufgebaut");
        }

        // Browser-Erkennung für spezielle Einstellungen
        const browserInfo = getBrowserInfo();
        console.log(`🌐 Browser: ${browserInfo.browser} ${browserInfo.version}`);
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        
        // Client-ID für Verbindungsidentifikation
        const clientId = getClientId();
        const sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // Browser-spezifische Parameter
        const browserParams = browserInfo.browser === 'Safari' ? '&browser=safari&safari=1' : 
                            browserInfo.browser === 'Firefox' ? '&browser=firefox' : 
                            browserInfo.browser === 'Edge' ? '&browser=edge' : '&browser=chrome';
        
        const wsUrl = `${protocol}//${window.location.host}?clientId=${clientId}&sessionId=${sessionId}&timestamp=${Date.now()}${browserParams}`;
        
        console.log(`🔗 Verbinde zu: ${wsUrl}`);
        
        try {
            ws = new WebSocket(wsUrl);
            
            // Browser-spezifische Timeouts
            if (browserInfo.browser === 'Safari') {
                console.log('🍎 Safari-Browser erkannt - aktiviere spezielle Einstellungen');
                
                // Kürzere Timeouts für Safari
                ws.addEventListener('open', () => {
                    console.log('✅ Safari WebSocket Verbindung hergestellt');
                    
                    // Sofortige Identifikation senden
                    const identifyMsg = {
                        type: 'client_identify',
                        clientId: clientId,
                        sessionId: sessionId,
                        userAgent: navigator.userAgent,
                        platform: getPlatformInfo().platform,
                        browser: 'Safari',
                        language: navigator.language,
                        timestamp: Date.now(),
                        isSafari: true,
                        isIOS: isIOS
                    };
                    
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify(identifyMsg));
                    }
                });
            }
            
            ws.onopen = () => {
                console.log(`✅ WebSocket Verbindung hergestellt (Client: ${clientId}, Session: ${sessionId}, Browser: ${browserInfo.browser})`);
                reconnectAttempts = 0;
                reconnectDelay = 1000;
                updateConnectionStatus(true, 'Verbunden');
                connectionStats.connectionStrength = 'good';
                connectionStats.clientId = clientId;
                connectionStats.sessionId = sessionId;
                connectionStats.browser = browserInfo.browser;
                
                showToast('✅ Mit Server verbunden', 'success');
                
                // Erweiterte Session-Info an Server senden
                const sessionInfo = {
                    type: 'client_identify',
                    clientId: clientId,
                    sessionId: sessionId,
                    userAgent: navigator.userAgent,
                    platform: getPlatformInfo().platform,
                    language: navigator.language,
                    timestamp: Date.now(),
                    previousSession: localStorage.getItem('lastSessionId') || null,
                    isSafari: browserInfo.browser === 'Safari',
                    isIOS: isIOS,
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        colorDepth: screen.colorDepth
                    }
                };
                
                // Sofortige Nachricht für Safari
                if (browserInfo.browser === 'Safari') {
                    setTimeout(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify(sessionInfo));
                            console.log('🍎 Safari-spezifische Identifikation gesendet');
                        }
                    }, 100);
                } else {
                    ws.send(JSON.stringify(sessionInfo));
                }
                
                // Letzte Session-ID speichern
                localStorage.setItem('lastSessionId', sessionId);
                
                // Raum wieder betreten falls vorhanden
                const savedRoom = localStorage.getItem('currentRoom');
                if (savedRoom && currentRoom === null) {
                    console.log('🔄 Versuche Raum wieder zu betreten:', savedRoom);
                    setTimeout(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'joinRoom',
                                roomId: savedRoom,
                                isSafari: browserInfo.browser === 'Safari'
                            }));
                        }
                    }, 1500);
                }
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    connectionStats.messagesReceived++;
                    connectionStats.bytesReceived += event.data.length;
                    connectionStats.lastMessageTime = Date.now();
                    
                    // Safari-spezifisches Logging
                    if (browserInfo.browser === 'Safari') {
                        console.log('🍎 Safari Nachricht empfangen:', data.type);
                    }
                    
                    // Verbindungs-Qualität überwachen
                    updateConnectionQuality();
                    
                    handleWebSocketMessage(data);
                } catch (error) {
                    console.error('❌ Fehler beim Verarbeiten der WebSocket-Nachricht:', error);
                    connectionStats.errors++;
                    
                    // Safari-spezifische Fehlerbehandlung
                    if (browserInfo.browser === 'Safari') {
                        console.log('🍎 Safari Fehlerbehandlung für Nachricht');
                    }
                }
            };
            
            ws.onclose = (event) => {
                console.log(`🔌 WebSocket Verbindung geschlossen (${clientId}, Browser: ${browserInfo.browser}):`, event.code, event.reason);
                updateConnectionStatus(false, 'Verbindung getrennt');
                
                // Safari-spezifische Schließungsbehandlung
                if (browserInfo.browser === 'Safari') {
                    console.log('🍎 Safari Verbindung geschlossen, Code:', event.code);
                    
                    // Spezielle Behandlung für Safari-spezifische Schließungs-Codes
                    if (event.code === 1001) {
                        console.log('🍎 Safari 1001 - Gehe weg oder Seite wird neu geladen');
                        showToast('🔌 Verbindung unterbrochen - Seite wird neu geladen?', 'warning');
                    }
                }
                
                // Cleanup
                if (window.heartbeatInterval) {
                    clearInterval(window.heartbeatInterval);
                    window.heartbeatInterval = null;
                }
                
                // Safari-spezifische Reconnect-Logik
                if (browserInfo.browser === 'Safari') {
                    // Aggressivere Reconnects für Safari
                    if (event.code !== 1000 && event.code !== 1001 && reconnectAttempts < maxReconnectAttempts) {
                        const timeout = Math.min(getReconnectTimeout(reconnectAttempts), 5000); // Max 5s für Safari
                        console.log(`🍎 Safari Reconnect in ${timeout/1000}s... (Versuch ${reconnectAttempts + 1}/${maxReconnectAttempts})`);
                        
                        setTimeout(() => {
                            reconnectAttempts++;
                            connectWebSocket();
                        }, timeout);
                        
                        showToast(`🔄 Verbindung wird wiederhergestellt... (${reconnectAttempts}/${maxReconnectAttempts})`, 'warning');
                    } else if (event.code === 1000) {
                        console.log('ℹ️ Safari Verbindung normal geschlossen');
                    } else {
                        console.error('❌ Maximales Safari Reconnect-Limit erreicht');
                        showToast('❌ Verbindung fehlgeschlagen. Bitte Seite neu laden.', 'error');
                    }
                } else {
                    // Normale Reconnect-Logik für andere Browser
                    if (event.code !== 1000 && event.code !== 1001 && reconnectAttempts < maxReconnectAttempts) {
                        const timeout = getReconnectTimeout(reconnectAttempts);
                        console.log(`🔄 Versuche erneute Verbindung in ${timeout/1000}s... (Versuch ${reconnectAttempts + 1}/${maxReconnectAttempts})`);
                        
                        setTimeout(() => {
                            reconnectAttempts++;
                            connectWebSocket();
                        }, timeout);
                        
                        showToast(`🔄 Verbindung wird wiederhergestellt... (${reconnectAttempts}/${maxReconnectAttempts})`, 'warning');
                    } else if (event.code === 1000) {
                        console.log('ℹ️ Verbindung normal geschlossen - kein Reconnect');
                    } else {
                        console.error('❌ Maximales Reconnect-Limit erreicht');
                        showToast('❌ Verbindung fehlgeschlagen. Bitte Seite neu laden.', 'error');
                    }
                }
            };
            
            ws.onerror = (error) => {
                console.error('❌ WebSocket Fehler:', error);
                
                // Safari-spezifische Fehlerbehandlung
                if (browserInfo.browser === 'Safari') {
                    console.log('🍎 Safari WebSocket Fehler - spezielle Behandlung');
                    
                    // Versuche sofortigen Reconnect bei Safari-Fehlern
                    if (reconnectAttempts === 0) {
                        setTimeout(() => {
                            reconnectAttempts++;
                            connectWebSocket();
                        }, 1000);
                    }
                }
                
                updateConnectionStatus(false, 'Verbindungsfehler');
                connectionStats.connectionStrength = 'poor';
                connectionStats.errors++;
            };
            
            // Browser-spezifischer Heartbeat
            if (browserInfo.browser === 'Safari') {
                setupSafariHeartbeat();
            } else {
                setupHeartbeat();
            }
            
        } catch (error) {
            console.error('❌ Fehler beim Herstellen der WebSocket-Verbindung:', error);
            
            // Safari-spezifische Fehlerbehandlung
            if (browserInfo.browser === 'Safari') {
                console.log('🍎 Safari Verbindungsfehler - alternative Strategie');
                
                // Versuche es sofort erneut für Safari
                if (reconnectAttempts < maxReconnectAttempts) {
                    setTimeout(() => {
                        reconnectAttempts++;
                        connectWebSocket();
                    }, 1000);
                }
            } else {
                // Normale Fehlerbehandlung für andere Browser
                updateConnectionStatus(false, 'Verbindungsfehler');
                connectionStats.errors++;
                
                // Retry mit exponentiellem Backoff
                if (reconnectAttempts < maxReconnectAttempts) {
                    const timeout = getReconnectTimeout(reconnectAttempts);
                    setTimeout(() => {
                        reconnectAttempts++;
                        connectWebSocket();
                    }, timeout);
                }
            }
        }
    }

    function showExtendedSafariWarning() {
        // Erstelle einen großen Warnhinweis-Banner
        const warningBanner = document.createElement('div');
        warningBanner.className = 'safari-warning-banner';
        warningBanner.innerHTML = `
            <div class="warning-content">
                <div class="warning-icon">
                    <i class="fas fa-exclamation-triangle"></i>
                </div>
                <div class="warning-text">
                    <h3>iOS Safari Einschränkung</h3>
                    <p>Dateiübertragungen werden in Safari auf iOS/iPadOS aufgrund technischer Einschränkungen nicht unterstützt.</p>
                    <p><strong>Bitte verwenden Sie eine dieser Alternativen:</strong></p>
                    <div class="browser-options">
                        <div class="browser-option" onclick="openAppStore('chrome')">
                            <i class="fab fa-chrome browser-chrome"></i>
                            <span>Google Chrome</span>
                        </div>
                        <div class="browser-option" onclick="openAppStore('firefox')">
                            <i class="fab fa-firefox-browser browser-firefox"></i>
                            <span>Mozilla Firefox</span>
                        </div>
                        <div class="browser-option" onclick="openAppStore('edge')">
                            <i class="fab fa-edge browser-edge"></i>
                            <span>Microsoft Edge</span>
                        </div>
                    </div>
                    <p class="warning-note">Diese Browser bieten bessere Unterstützung für Dateiübertragungen und WebSocket-Verbindungen.</p>
                </div>
            </div>
        `;
        
        // Füge Styles hinzu
        const style = document.createElement('style');
        style.textContent = `
            .safari-warning-banner {
                background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
                border: 3px solid #f59e0b;
                border-radius: 16px;
                padding: 2rem;
                margin: 2rem auto;
                max-width: 600px;
                box-shadow: 0 10px 25px rgba(245, 158, 11, 0.3);
            }
            .dark .safari-warning-banner {
                background: linear-gradient(135deg, #451a03 0%, #78350f 100%);
                border-color: #d97706;
            }
            .warning-content {
                display: flex;
                align-items: flex-start;
                gap: 1.5rem;
            }
            .warning-icon {
                font-size: 3rem;
                color: #d97706;
                flex-shrink: 0;
            }
            .warning-text h3 {
                color: #92400e;
                font-size: 1.5rem;
                margin-bottom: 1rem;
                font-weight: bold;
            }
            .dark .warning-text h3 {
                color: #fbbf24;
            }
            .warning-text p {
                color: #92400e;
                margin-bottom: 0.5rem;
                line-height: 1.5;
            }
            .dark .warning-text p {
                color: #fde68a;
            }
            .browser-options {
                display: flex;
                gap: 1rem;
                margin: 1.5rem 0;
                flex-wrap: wrap;
            }
            .browser-option {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 1rem;
                border: 2px solid transparent;
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.3s ease;
                background: rgba(255, 255, 255, 0.5);
                min-width: 100px;
            }
            .dark .browser-option {
                background: rgba(0, 0, 0, 0.3);
            }
            .browser-option:hover {
                transform: translateY(-3px);
                border-color: #f59e0b;
                box-shadow: 0 5px 15px rgba(245, 158, 11, 0.2);
            }
            .browser-option i {
                font-size: 2rem;
                margin-bottom: 0.5rem;
            }
            .browser-option span {
                font-weight: 600;
                color: #92400e;
                text-align: center;
            }
            .dark .browser-option span {
                color: #fde68a;
            }
            .warning-note {
                font-size: 0.9rem;
                font-style: italic;
                margin-top: 1rem;
                opacity: 0.8;
            }
        `;
        
        document.head.appendChild(style);
        
        // Füge Banner nach dem Header ein
        const header = document.querySelector('header');
        if (header) {
            header.parentNode.insertBefore(warningBanner, header.nextSibling);
        } else {
            document.body.insertBefore(warningBanner, document.body.firstChild);
        }
        
        // Zeige zusätzlichen Toast
        showToast('❌ iOS Safari wird nicht unterstützt. Bitte alternative Browser verwenden.', 'error', 10000);
    }

    // Hilfsfunktion für App Store Links
    function openAppStore(browser) {
        const appLinks = {
            chrome: 'https://apps.apple.com/app/google-chrome/id535886823',
            firefox: 'https://apps.apple.com/app/firefox-web-browser/id989804926',
            edge: 'https://apps.apple.com/app/microsoft-edge/id1288723196'
        };
        
        window.open(appLinks[browser], '_blank');
        showToast(`Öffne ${browser} im App Store...`, 'info');
    }

    // Client-ID generieren und speichern
    function getClientId() {
        let clientId = localStorage.getItem('websocket_client_id');
        if (!clientId) {
            // Erstelle eine eindeutige Client-ID mit Browser-Fingerprinting
            const fingerprint = generateBrowserFingerprint();
            clientId = 'client_' + fingerprint + '_' + Date.now();
            localStorage.setItem('websocket_client_id', clientId);
        }
        return clientId;
    }

    function generateBrowserFingerprint() {
        const components = [
            navigator.userAgent,
            navigator.language,
            navigator.hardwareConcurrency || 'unknown',
            screen.colorDepth,
            screen.width + 'x' + screen.height,
            new Date().getTimezoneOffset()
        ];
        
        let fingerprint = components.join('|');
        let hash = 0;
        for (let i = 0; i < fingerprint.length; i++) {
            const char = fingerprint.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash).toString(36);
    }

    // Safari-spezifischer Heartbeat
    function setupSafariHeartbeat() {
        if (window.safariHeartbeatInterval) {
            clearInterval(window.safariHeartbeatInterval);
        }
        
        let missedPings = 0;
        const maxMissedPings = 2; // Weniger tolerant für Safari
        
        console.log('🍎 Starte Safari-spezifischen Heartbeat');
        
        window.safariHeartbeatInterval = setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const pingMsg = {
                    type: 'ping',
                    clientId: getClientId(),
                    sessionId: connectionStats.sessionId,
                    timestamp: Date.now(),
                    browser: 'safari',
                    stats: {
                        messagesReceived: connectionStats.messagesReceived,
                        bytesReceived: connectionStats.bytesReceived,
                        errors: connectionStats.errors
                    }
                };
                
                // Strengere Überwachung für Safari
                if (connectionStats.lastPingTime && (Date.now() - connectionStats.lastPingTime) > 25000) {
                    missedPings++;
                    console.warn(`🍎 Safari Ping nicht beantwortet (${missedPings}/${maxMissedPings})`);
                    
                    if (missedPings >= maxMissedPings) {
                        console.error('❌ Zu viele Safari Pings verpasst - Verbindung wird neu aufgebaut');
                        if (ws) {
                            ws.close(1006, 'Safari ping timeout');
                        }
                        return;
                    }
                }
                
                ws.send(JSON.stringify(pingMsg));
                connectionStats.lastPingTime = Date.now();
                connectionStats.pingsSent++;
                
            } else if (ws && ws.readyState === WebSocket.CONNECTING) {
                console.log('🍎 Safari WebSocket verbindet noch...');
            } else {
                // Verbindung nicht offen - Interval bereinigen
                clearInterval(window.safariHeartbeatInterval);
                window.safariHeartbeatInterval = null;
            }
        }, 10000); // Alle 10 Sekunden für Safari (statt 15)
    }

    function getReconnectTimeout(attempt) {
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        
        if (isSafari) {
            // Kürzere Timeouts für Safari
            const baseDelay = 500;
            const maxDelay = 10000; // 10s max für Safari
            const exponentialDelay = baseDelay * Math.pow(1.5, attempt);
            const jitter = Math.random() * 500; // Weniger Jitter für Safari
            return Math.min(exponentialDelay + jitter, maxDelay);
        } else {
            // Normale Timeouts für andere Browser
            const baseDelay = 1000;
            const maxDelay = 30000;
            const exponentialDelay = baseDelay * Math.pow(1.5, attempt);
            const jitter = Math.random() * 1000;
            return Math.min(exponentialDelay + jitter, maxDelay);
        }
    }
    // Heartbeat-Mechanismus
    function setupHeartbeat() {
        if (window.heartbeatInterval) {
            clearInterval(window.heartbeatInterval);
        }
        
        let missedPings = 0;
        const maxMissedPings = 3;
        
        window.heartbeatInterval = setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const pingMsg = {
                    type: 'ping',
                    clientId: getClientId(),
                    sessionId: connectionStats.sessionId,
                    timestamp: Date.now(),
                    stats: {
                        messagesReceived: connectionStats.messagesReceived,
                        bytesReceived: connectionStats.bytesReceived,
                        errors: connectionStats.errors
                    }
                };
                
                // Prüfe ob letzter Ping beantwortet wurde
                if (connectionStats.lastPingTime && (Date.now() - connectionStats.lastPingTime) > 45000) {
                    missedPings++;
                    console.warn(`⚠️ Ping nicht beantwortet (${missedPings}/${maxMissedPings})`);
                    
                    if (missedPings >= maxMissedPings) {
                        console.error('❌ Zu viele Pings verpasst - Verbindung wird neu aufgebaut');
                        if (ws) {
                            ws.close(1006, 'Ping timeout');
                        }
                        return;
                    }
                }
                
                ws.send(JSON.stringify(pingMsg));
                connectionStats.lastPingTime = Date.now();
                connectionStats.pingsSent++;
                
            } else if (ws && ws.readyState === WebSocket.CONNECTING) {
                console.log('⏳ WebSocket verbindet noch...');
            } else {
                // Verbindung nicht offen - Interval bereinigen
                clearInterval(window.heartbeatInterval);
                window.heartbeatInterval = null;
            }
        }, 15000); // Alle 15 Sekunden (statt 30)
    }

    function updateConnectionQuality() {
        const now = Date.now();
        
        // Berechne Nachrichten pro Minute
        if (connectionStats.lastMessageTime) {
            const timeDiff = (now - connectionStats.lastMessageTime) / 1000;
            if (timeDiff > 60) {
                // Reset stats nach langer Inaktivität
                connectionStats.messagesPerMinute = 0;
            }
        }
        
        // Verbindungsstärke basierend auf Latenz und Fehlerrate
        const errorRate = connectionStats.errors / Math.max(connectionStats.messagesReceived, 1);
        
        if (errorRate > 0.1) {
            connectionStats.connectionStrength = 'poor';
        } else if (errorRate > 0.05) {
            connectionStats.connectionStrength = 'average';
        } else {
            connectionStats.connectionStrength = 'good';
        }
        
        updateConnectionStrengthDisplay();
    }

    // Verbindung sauber schließen
    function disconnectWebSocket(reason = "Benutzeraktion") {
        console.log(`🔌 Schließe WebSocket Verbindung: ${reason}`);
        
        if (window.heartbeatInterval) {
            clearInterval(window.heartbeatInterval);
            window.heartbeatInterval = null;
        }
        
        if (ws) {
            // Sende Leave-Message falls in einem Raum
            if (currentRoom && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'leaveRoom',
                    reason: reason
                }));
            }
            
            ws.onclose = null; // Verhindere Reconnect
            ws.close(1000, reason);
            ws = null;
        }
        
        reconnectAttempts = maxReconnectAttempts; // Stoppe Reconnect-Versuche
        updateConnectionStatus(false, 'Getrennt');
    }

    // Bei Seitenverlassen sauber trennen
    window.addEventListener('beforeunload', () => {
        disconnectWebSocket("Seite verlassen");
    });

    // Visibility Change - Reconnect wenn Seite wieder sichtbar
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && (!ws || ws.readyState !== WebSocket.OPEN)) {
            console.log('🔄 Seite wieder sichtbar - versuche Reconnect');
            connectWebSocket();
        }
    });
    
    // Verbesserte Nachrichtenverarbeitung
    function handleWebSocketMessage(data) {

        connectionStats.lastMessageTime = Date.now();

        switch (data.type) {
            case 'welcome':
                handleWelcome(data);
                break;

            case 'session_restored':
                handleSessionRestored(data);
                break;

            case 'duplicate_connection':
                handleDuplicateConnection(data);
                break;

            case 'fileComplete':
                handleFileComplete(data);
                break;
                
            case 'deviceList':
                updateDeviceList(data.devices);
                if (data.roomInfo) {
                    updateRoomInfo(data.roomInfo);
                }
                break;
                
            case 'incomingFile':
                showIncomingFilesModal(data.files, data.fromDevice, data.fromDeviceId, data.transferId, data.totalSize, data.supportsChunks);
                break;
                
            case 'transferStarted':
                handleTransferStarted(data);
                break;
                
            case 'transferError':
                handleTransferError(data);
                break;

            case 'sendFileData':
                handleSendFileData(data);
                break;
                
            case 'fileData':
                handleFileData(data);
                break;
                
            case 'uploadProgress':
                handleUploadProgress(data);
                break;
                
            case 'transferProgress':
                handleTransferProgress(data);
                break;
                
            case 'transferReady':
                handleTransferReady(data);
                break;
                
            case 'transferRejected':
                handleTransferRejected(data);
                break;
                
            case 'transferAccepted':
                handleTransferAccepted(data);
                break;
                
            case 'deviceNameUpdated':
                handleDeviceNameUpdated(data);
                break;

            case 'deviceList':
                console.log('📨 Geräteliste empfangen:', {
                    anzahl: data.devices ? data.devices.length : 0,
                    geräte: data.devices,
                    raumInfo: data.roomInfo
                });
                updateDeviceList(data.devices);
                if (data.roomInfo) {
                    updateRoomInfo(data.roomInfo);
                }
                break;
                
            case 'roomCreated':
                handleRoomCreated(data);
                break;
                
            case 'roomJoined':
                handleRoomJoined(data);
                break;

            case 'transferComplete':
                handleTransferComplete(data);
                break;
                
            case 'roomLeft':
                handleRoomLeft();
                break;
                
            case 'roomError':
                handleRoomError(data);
                break;
                
            case 'deviceJoined':
                handleDeviceJoined(data);
                break;
                
            case 'deviceLeft':
                handleDeviceLeft(data);
                break;
                
            case 'pong':
                handlePong(data);
                break;
                
            case 'error':
                handleError(data);
                break;
                
            default:
                console.warn(`⚠️ Unbekannter Nachrichtentyp: ${data.type}`, data);
        }
    }

    // Füge diese Funktion NACH handleTransferRejected hinzu:
    function handleTransferAccepted(data) {
        console.log('✅ Übertragung akzeptiert:', data);
        showToast('✅ Dateiübertragung wurde akzeptiert', 'success');
        
        // Starte den Download automatisch
        if (data.transferId && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'requestFileDownload',
                transferId: data.transferId,
                fileIndex: 0,
                chunkSize: chunkSize
            }));
        }
    }

    // Und definiere die Funktion:
    function handleTransferComplete(data) {
        console.log('✅ Übertragung abgeschlossen:', data);
        showToast(`✅ "${data.fileName}" erfolgreich übertragen`, 'success');
        
        // Übertragung aus aktiven Transfers entfernen
        if (data.transferId) {
            activeTransfers.delete(data.transferId);
            updateActiveTransfers();
        }
        
        // Schließe das Fortschritts-Modal falls geöffnet
        if (currentTransfer && currentTransfer.id === data.transferId) {
            transferProgressModal.classList.add('hidden');
            currentTransfer = null;
        }
    }

    function disableAllTransferFeatures() {
        console.log('🚫 Deaktiviere Transfer-Features für iOS Safari');
        
        // Upload-Bereich deaktivieren
        if (uploadArea) {
            uploadArea.style.opacity = '0.5';
            uploadArea.style.pointerEvents = 'none';
            uploadArea.innerHTML = `
                <div class="text-center">
                    <i class="fas fa-exclamation-triangle text-yellow-500 text-3xl mb-4"></i>
                    <p class="text-gray-600 font-medium mb-2">iOS Safari wird nicht unterstützt</p>
                    <p class="text-gray-500 text-sm">Bitte verwenden Sie Chrome, Firefox oder Edge für Dateiübertragungen</p>
                </div>
            `;
        }
        
        // Gerätebereich deaktivieren
        if (devicesSection) {
            devicesSection.style.opacity = '0.5';
            devicesSection.style.pointerEvents = 'none';
        }
        
        // Datei-Eingabe deaktivieren
        if (fileInput) {
            fileInput.disabled = true;
        }
        
        // Buttons deaktivieren
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
            if (button.id !== 'themeToggle') {
                button.disabled = true;
                button.style.opacity = '0.5';
            }
        });
        
        // Raum-Funktionen deaktivieren mit spezieller Nachricht
        if (createRoomBtn && joinRoomBtn) {
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            createRoomBtn.innerHTML = '<i class="fas fa-exclamation-triangle mr-2"></i>Nicht verfügbar';
            joinRoomBtn.innerHTML = '<i class="fas fa-exclamation-triangle mr-2"></i>Nicht verfügbar';
        }
    }

    function handleTransferRejected(data) {
        console.log('❌ Übertragung abgelehnt:', data);
        showToast('❌ Dateiübertragung wurde abgelehnt', 'error');
        
        // Bereinige die Übertragung
        if (data.transferId) {
            activeTransfers.delete(data.transferId);
            updateActiveTransfers();
        }
    }
    
    // Nachrichtenhandler
    function handleWelcome(data) {
        currentDeviceId = data.deviceId;
        serverInfo = data.serverInfo || {};
        sendDeviceInfo();
        showToast('✅ Gerät erfolgreich registriert', 'success');
    }
    
    function handleUploadProgress(data) {
        updateUploadProgress(data.transferId, data.progress, data.chunkIndex, data.totalChunks);
        
        // Chunk-Statistiken aktualisieren
        if (data.totalChunks) {
            chunkStats.totalChunks = data.totalChunks;
            chunkStats.receivedChunks = data.chunkIndex + 1;
            chunkStats.lastChunkTime = Date.now();
            
            console.log(`📊 Chunk-Fortschritt: ${chunkStats.receivedChunks}/${chunkStats.totalChunks}`);
        }
    }
    
    function handleTransferProgress(data) {
        updateTransferProgress(data.transferId, data.progress, data.fileIndex);
    }
    
    function handleTransferReady(data) {
        console.log('✅ Dateien bereit zum Download:', data.files);
        
        // Automatisch die erste Datei anfordern
        if (data.files && data.files.length > 0 && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'requestFileDownload',
                transferId: data.transferId,
                fileIndex: 0,
                chunkSize: chunkSize
            }));
            
            showToast(`📥 "${data.files[0].name}" wird heruntergeladen...`, 'info');
        }
        
        updateActiveTransfers();
    }
    
    function handleTransferStarted(data) {
        addTransferToHistory({
            id: data.transferId,
            type: 'outgoing',
            targetDevice: data.targetDevice,
            files: selectedFiles.map(f => ({ name: f.name, size: f.size })),
            status: 'started',
            timestamp: new Date()
        });
        showToast(`📤 Übertragung an ${data.targetDevice} gestartet`, 'info');
    }
    
    function handleTransferError(data) {
        showToast(`❌ Übertragungsfehler: ${data.message}`, 'error');
        if (currentTransfer && currentTransfer.id === data.transferId) {
            transferProgressModal.classList.add('hidden');
            currentTransfer = null;
        }
        updateActiveTransfers();
    }
    
    function handleDeviceNameUpdated(data) {
        showToast('✅ Gerätename aktualisiert', 'success');
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'ping' }));
        }
    }
    
    function handleRoomError(data) {
        showToast(`❌ Raum-Fehler: ${data.message}`, 'error');
    }
    
    function handleDeviceJoined(data) {
        showToast(`📱 ${data.deviceName} ist dem Raum beigetreten (${data.deviceCount} Geräte)`, 'info');
    }
    
    function handleDeviceLeft(data) {
        showToast(`🚪 ${data.deviceName} hat den Raum verlassen (${data.deviceCount} Geräte)`, 'info');
    }
    
    function handlePong(data) {
        connectionStats.pongsReceived++;
        const pingTime = Date.now() - data.timestamp;
        
        // Verbindungsqualität basierend auf Ping-Zeit
        if (pingTime < 100) {
            connectionStats.connectionStrength = 'excellent';
        } else if (pingTime < 300) {
            connectionStats.connectionStrength = 'good';
        } else if (pingTime < 1000) {
            connectionStats.connectionStrength = 'average';
        } else {
            connectionStats.connectionStrength = 'poor';
        }
        
        updateConnectionStrengthDisplay();
    }

    function handleSessionRestored(data) {
        console.log('🔄 Vorherige Session wurde wiederhergestellt:', data);
        showToast('🔌 Vorherige Verbindung wurde aktualisiert', 'info');
        
        // Raum-Status wiederherstellen falls nötig
        if (data.room) {
            currentRoom = data.room;
            showRoomInterface();
        }
    }

    function handleDuplicateConnection(data) {
        console.log('🔄 Duplikat-Verbindung erkannt:', data);
        
        if (data.keepThisConnection) {
            showToast('✅ Neue Verbindung aktiviert', 'success');
            // Diese Verbindung wird beibehalten
        } else {
            showToast('🔄 Vorherige Verbindung wird beibehalten', 'info');
            // Diese Verbindung schließen
            setTimeout(() => {
                if (ws) {
                    ws.close(1000, "Duplicate connection");
                }
            }, 1000);
        }
    }

    function setupNetworkMonitoring() {
        // Online/Offline Events
        window.addEventListener('online', () => {
            console.log('🌐 Netzwerk-Verbindung wiederhergestellt');
            showToast('✅ Netzwerk verbunden', 'success');
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                setTimeout(() => {
                    reconnectAttempts = 0;
                    connectWebSocket();
                }, 1000);
            }
        });
        
        window.addEventListener('offline', () => {
            console.log('🌐 Netzwerk-Verbindung verloren');
            showToast('❌ Netzwerk getrennt', 'error');
            updateConnectionStatus(false, 'Offline');
        });
        
        // Visibility Change mit verbesserter Logik
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                // Seite wieder sichtbar - Verbindung prüfen
                console.log('👀 Seite wieder sichtbar - prüfe Verbindung...');
                
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    console.log('🔄 Verbindung geschlossen - starte Reconnect');
                    setTimeout(() => {
                        reconnectAttempts = 0;
                        connectWebSocket();
                    }, 500);
                } else {
                    // Sende Ping um Verbindung zu testen
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'ping',
                            clientId: getClientId(),
                            timestamp: Date.now(),
                            reason: 'visibility_change'
                        }));
                    }
                }
            }
        });
    }

    
    function handleError(data) {
        showToast(`❌ Server-Fehler: ${data.message}`, 'error');
    }

    function handleSendFileData(data) {
        const transfer = activeTransfers.get(data.transferId);
        if (!transfer) return;
        
        const file = transfer.files[data.fileIndex];
        if (!file) return;
        
        const targetChunkSize = data.chunkSize || chunkSize;
        const totalChunks = Math.ceil(file.size / targetChunkSize);
        
        transfer.status = 'transferring';
        transfer.currentFileIndex = data.fileIndex;
        transfer.currentFile = file.name;
        transfer.totalChunks = totalChunks;
        transfer.sentChunks = 0;
        
        sendNextChunk(transfer, data.targetDeviceId, data.transferId, data.fileIndex, targetChunkSize);
    }
    
    function handleRoomCreated(data) {
        currentRoom = data;
        showRoomInterface();
        showToast(`🏠 Raum "${data.roomName}" erstellt`, 'success');
    }
    
    function handleRoomJoined(data) {
        console.log('🚪 Raum beigetreten:', data);
        currentRoom = data;
        showRoomInterface();
        
        // Speichere den Raum im localStorage für Wiederherstellung
        localStorage.setItem('currentRoom', data.roomId);
        
        showToast(`🚪 Raum "${data.roomName}" beigetreten (${data.deviceCount} Geräte)`, 'success');
        
        // Frage die Geräteliste nach 1 Sekunde erneut an (falls nicht automatisch kommt)
        setTimeout(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'ping',
                    requestDeviceList: true
                }));
            }
        }, 1000);
    }
        
    function handleRoomLeft() {
        currentRoom = null;
        hideRoomInterface();
        showToast('🚪 Raum verlassen', 'info');
    }
    
    // Verbesserte Dateiauswahl mit Größenprüfung
    function handleFileSelect(e) {
        const files = Array.from(e.target.files);
        processFiles(files);
    }
    
    function handleDragOver(e) {
        e.preventDefault();
        uploadArea.classList.add('border-orange-500', 'bg-orange-100', 'dark:bg-orange-900/30');
    }
    
    function handleFileDrop(e) {
        e.preventDefault();
        uploadArea.classList.remove('border-orange-500', 'bg-orange-100', 'dark:bg-orange-900/30');
        
        const files = Array.from(e.dataTransfer.files);
        processFiles(files);
    }
    
    function processFiles(files) {
        const validFiles = files.filter(file => {
            // Größenprüfung (500MB Limit)
            if (file.size > 500 * 1024 * 1024) {
                showToast(`❌ Datei zu groß: ${file.name} (${formatFileSize(file.size)})`, 'error');
                return false;
            }
            
            // Dateityp-Prüfung
            const dangerousTypes = ['.exe', '.bat', '.cmd', '.sh', '.php', '.js', '.jar'];
            const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
            if (dangerousTypes.includes(fileExtension)) {
                showToast(`❌ Dateityp nicht erlaubt: ${file.name}`, 'error');
                return false;
            }
            
            return true;
        });
        
        selectedFiles = [...selectedFiles, ...validFiles];
        updateFileList();
        
        if (validFiles.length > 0) {
            showToast(`✅ ${validFiles.length} Datei(en) hinzugefügt`, 'success');
        }
    }
    
    // Verbesserte Dateiliste mit Fortschrittsanzeige
    function updateFileList() {
        fileListContainer.innerHTML = '';
        
        if (selectedFiles.length === 0) {
            fileList.classList.add('hidden');
            selectedFilesCount.classList.add('hidden');
            fileSizeWarning.classList.add('hidden');
            return;
        }
        
        fileList.classList.remove('hidden');
        selectedFilesCount.classList.remove('hidden');
        selectedFilesCount.textContent = selectedFiles.length;
        
        let totalSize = 0;
        let largeFiles = 0;
        
        selectedFiles.forEach((file, index) => {
            totalSize += file.size;
            if (file.size > 100 * 1024 * 1024) { // 100MB als "groß" betrachten
                largeFiles++;
            }
            
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item bg-gray-50 rounded-lg p-3 flex items-center justify-between dark:bg-gray-600';
            
            const fileIcon = getFileIcon(file.type);
            const fileType = getFileType(file.type);
            
            fileItem.innerHTML = `
                <div class="flex items-center space-x-3 min-w-0 flex-grow">
                    <div class="w-10 h-10 bg-orange-100 rounded-lg flex items-center justify-center flex-shrink-0 dark:bg-orange-900">
                        <i class="${fileIcon} text-orange-500 text-sm"></i>
                    </div>
                    <div class="min-w-0 flex-grow">
                        <p class="font-medium text-gray-800 text-sm truncate dark:text-white">${file.name}</p>
                        <div class="flex items-center space-x-2 mt-1">
                            <span class="file-type-badge file-type-${fileType}">${getFileTypeName(file.type)}</span>
                            <span class="text-xs text-gray-500 dark:text-gray-400">${formatFileSize(file.size)}</span>
                        </div>
                    </div>
                </div>
                <button class="text-red-500 hover:text-red-700 delete-file touch-button ml-2 flex-shrink-0" data-index="${index}">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            fileListContainer.appendChild(fileItem);
        });
        
        // Dateigrößen-Warnung
        if (largeFiles > 0) {
            fileSizeWarning.classList.remove('hidden');
            largeFileCount.textContent = `${largeFiles} große`;
        } else {
            fileSizeWarning.classList.add('hidden');
        }
        
        totalFileSize.textContent = formatFileSize(totalSize);
        
        // Event-Listener für Löschen-Buttons
        document.querySelectorAll('.delete-file').forEach(button => {
            button.addEventListener('click', (e) => {
                const index = parseInt(e.currentTarget.getAttribute('data-index'));
                selectedFiles.splice(index, 1);
                updateFileList();
            });
        });
    }
    
    function clearAllFiles() {
        selectedFiles = [];
        updateFileList();
        showToast('🗑️ Alle Dateien entfernt', 'info');
    }
    
    // Verbesserte Dateiübertragung mit Chunk-Support
    function sendFilesToDevice(device) {
        if (selectedFiles.length === 0) {
            showToast('❌ Keine Dateien zum Senden ausgewählt', 'error');
            return;
        }
        
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            showToast('❌ Keine Verbindung zum Server', 'error');
            return;
        }
        
        if (!device.online) {
            showToast('❌ Gerät ist offline', 'error');
            return;
        }
        
        const transferId = 'transfer-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        const fileInfos = selectedFiles.map(file => ({
            name: file.name,
            size: file.size,
            type: file.type
        }));
        
        const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
        
        // Starte Übertragung
        ws.send(JSON.stringify({
            type: 'fileTransfer',
            targetDeviceId: device.id,
            files: fileInfos,
            transferId: transferId,
            chunkSize: chunkSize
        }));
        
        // Speichere Dateien für Chunk-Übertragung
        activeTransfers.set(transferId, {
            id: transferId,
            files: selectedFiles,
            targetDevice: device.customName || device.name,
            targetDeviceId: device.id,
            status: 'pending',
            progress: 0,
            startTime: Date.now(),
            totalSize: totalSize
        });
        
        showToast(`📤 Übertragung an ${device.customName || device.name} gestartet`, 'info');
        updateActiveTransfers();
        
        // Dateiliste zurücksetzen
        selectedFiles = [];
        updateFileList();
    }
    
    // Chunk-basierte Dateiübertragung
    function sendNextChunk(transfer, targetDeviceId, transferId, fileIndex, chunkSize) {
        const file = transfer.files[fileIndex];
        const start = transfer.sentChunks * chunkSize;
        const end = Math.min(start + chunkSize, file.size);
        
        if (start >= file.size) {
            transfer.sentChunks = 0;
            updateActiveTransfers();
            return;
        }
        
        const chunk = file.slice(start, end);
        const reader = new FileReader();
        
        reader.onload = (e) => {
            const chunkData = e.target.result;
            
            // 🔥 WARNHINWEIS bei großen Nachrichten
            if (chunkData.length > 500000) { // ~500KB
                console.warn('⚠️ Große WebSocket-Nachricht:', {
                    size: chunkData.length,
                    chunkIndex: transfer.sentChunks,
                    transferId: transferId
                });
            }
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'fileChunk',
                    targetDeviceId: targetDeviceId,
                    transferId: transferId,
                    fileIndex: fileIndex,
                    chunkIndex: transfer.sentChunks,
                    totalChunks: transfer.totalChunks,
                    data: chunkData,
                    fileSize: file.size
                }));
                
                transfer.sentChunks++;
                const progress = Math.round((transfer.sentChunks / transfer.totalChunks) * 100);
                
                ws.send(JSON.stringify({
                    type: 'fileProgress',
                    targetDeviceId: targetDeviceId,
                    transferId: transferId,
                    progress: progress,
                    fileIndex: fileIndex
                }));
                
                if (transfer.sentChunks < transfer.totalChunks) {
                    setTimeout(() => {
                        sendNextChunk(transfer, targetDeviceId, transferId, fileIndex, chunkSize);
                    }, 50); // 🔥 Erhöhte Verzögerung für Stabilität
                }
            }
        };
        
        reader.readAsDataURL(chunk);
    }
    
    // Verbesserte Fortschrittsanzeige
    function updateUploadProgress(transferId, progress, chunkIndex, totalChunks) {
        const transfer = activeTransfers.get(transferId);
        if (transfer) {
            transfer.progress = progress;
            transfer.status = 'transferring';
            updateActiveTransfers();
            
            if (progress === 100) {
                transfer.status = 'completed';
                transfer.endTime = Date.now();
                addTransferToHistory({
                    id: transferId,
                    type: 'outgoing',
                    targetDevice: transfer.targetDevice,
                    files: transfer.files.map(f => ({ name: f.name, size: f.size })),
                    status: 'completed',
                    timestamp: new Date(),
                    duration: transfer.endTime - transfer.startTime
                });
                showToast(`✅ Übertragung an ${transfer.targetDevice} abgeschlossen`, 'success');
            }
        }
    }
    
    function updateTransferProgress(transferId, progress, fileIndex) {
        // Aktualisiere Fortschritt in der UI
        if (currentTransfer && currentTransfer.id === transferId) {
            transferFileProgress.textContent = `${progress}%`;
            transferProgressBar.style.width = `${progress}%`;
            
            // Erfolgs-Animation bei 100%
            if (progress === 100) {
                transferProgressBar.classList.add('transfer-complete');
                transferFileProgress.innerHTML = '<span class="success-checkmark">✅</span> 100%';
                
                // Erfolgs-Toast nach kurzer Verzögerung
                setTimeout(() => {
                    showToast(`✅ "${currentTransfer.currentFile}" erfolgreich übertragen!`, 'success');
                }, 800);

                // Modal nach 3 Sekunden schließen
                setTimeout(() => {
                    transferProgressModal.classList.add('hidden');
                    currentTransfer = null;
                    transferStartTime = null;
                }, 3000);
            } else {
                transferProgressBar.classList.remove('transfer-complete');
            }
            
            // Berechne Geschwindigkeit und verbleibende Zeit
            if (transferStartTime) {
                const elapsed = Date.now() - transferStartTime;
                const transferred = (currentTransfer.totalSize * progress / 100);
                const speed = progress > 0 ? transferred / (elapsed / 1000) : 0;
                const remaining = progress > 0 ? (elapsed / progress) * (100 - progress) : 0;
                
                transferSpeed.textContent = `Geschwindigkeit: ${formatFileSize(speed)}/s`;
                transferTime.textContent = `Verbleibend: ${formatTime(remaining)}`;
            }
        }
        
        // Aktualisiere auch in der aktiven Transfers Liste
        updateActiveTransfers();
    }
    
    // Verbesserte Geräteverwaltung
    function updateDeviceList(devices) {
        console.log('📱 Aktualisiere Geräteliste:', devices);
        
        if (!devicesList) {
            console.error('❌ devicesList Element nicht gefunden');
            return;
        }
        
        devicesList.innerHTML = '';
        
        if (devices && devices.length > 0) {
            let onlineCount = 0;
            let pinnedCount = 0;
            
            // Filtere das eigene Gerät heraus und sortiere
            const filteredDevices = devices.filter(device => {
                const isCurrentDevice = device.id === currentDeviceId;
                if (!isCurrentDevice && device.online) onlineCount++;
                if (device.pinned) pinnedCount++;
                return !isCurrentDevice;
            });
            
            // Sortiere Geräte: zuerst gepinnte, dann online, dann nach Name
            const sortedDevices = filteredDevices.sort((a, b) => {
                if (a.pinned && !b.pinned) return -1;
                if (!a.pinned && b.pinned) return 1;
                if (a.online && !b.online) return -1;
                if (!a.online && b.online) return 1;
                return (a.customName || a.name).localeCompare(b.customName || b.name);
            });
            
            console.log(`📊 Gefilterte Geräte: ${filteredDevices.length}, Online: ${onlineCount}`);
            
            if (sortedDevices.length === 0) {
                devicesList.innerHTML = `
                    <div class="text-center py-6 text-gray-500 dark:text-gray-400 col-span-full">
                        <i class="fas fa-users-slash text-2xl mb-2"></i>
                        <p class="text-sm">Keine anderen Geräte im Raum gefunden</p>
                        <p class="text-xs mt-1">Warten Sie bis andere Geräte dem Raum beitreten</p>
                    </div>
                `;
            } else {
                sortedDevices.forEach(device => {
                    addDeviceToList(device);
                });
            }
            
            devicesCount.textContent = onlineCount.toString();
            updateRoomDeviceDisplay(onlineCount + 1); // +1 für das eigene Gerät
            
        } else {
            devicesList.innerHTML = `
                <div class="text-center py-6 text-gray-500 dark:text-gray-400 col-span-full">
                    <i class="fas fa-users-slash text-2xl mb-2"></i>
                    <p class="text-sm">Keine Geräte im Raum gefunden</p>
                    <p class="text-xs mt-1">Andere Geräte müssen demselben Raum beitreten</p>
                </div>
            `;
            devicesCount.textContent = '0';
            updateRoomDeviceDisplay(1); // Nur eigenes Gerät
        }
    }
    
    function addDeviceToList(device) {
        console.log('➕ Füge Gerät zur Liste hinzu:', device);
        
        const deviceCard = document.createElement('div');
        
        let statusClass = device.online ? 'status-online' : 'status-offline';
        let statusText = device.online ? 'Online' : 'Offline';
        
        const platformClass = `platform-${(device.platform || 'unknown').toLowerCase()}`;
        const browserClass = `browser-${(device.browser || 'unknown').toLowerCase()}`;
        
        const customName = customDeviceNames[device.id];
        const displayName = customName || device.name || 'Unbekanntes Gerät';
        const hasCustomName = !!customName;
        
        deviceCard.className = `device-card bg-white border border-gray-200 rounded-lg p-4 flex items-center space-x-4 transition duration-300 dark:device-card ${device.pinned ? 'pinned-device' : ''} ${!device.online ? 'opacity-60' : ''}`;
        
        const iconClass = device.type === 'mobile' ? 'fas fa-mobile-alt' : 
                        device.type === 'tablet' ? 'fas fa-tablet-alt' : 'fas fa-laptop';
        
        deviceCard.innerHTML = `
            <div class="flex-shrink-0">
                <div class="w-12 h-12 bg-gray-100 rounded-lg flex items-center justify-center dark:bg-gray-600">
                    <i class="${iconClass} ${platformClass} text-lg"></i>
                </div>
            </div>
            
            <div class="flex-grow min-w-0">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center min-w-0">
                        <h3 class="font-semibold text-gray-800 text-sm truncate dark:text-white">${displayName}</h3>
                        ${hasCustomName ? '<span class="custom-name-badge ml-2">Eigen</span>' : ''}
                        ${device.pinned ? '<i class="fas fa-star text-yellow-500 ml-2 text-xs"></i>' : ''}
                    </div>
                    <div class="flex items-center space-x-2 flex-shrink-0 ml-2">
                        <span class="${statusClass} text-xs px-2 py-1 rounded-full">${statusText}</span>
                        ${device.online ? `
                            <div class="connection-strength">
                                <div class="strength-bar ${device.connectionStrength || 'good'}"></div>
                                <div class="strength-bar ${device.connectionStrength || 'good'}"></div>
                                <div class="strength-bar ${device.connectionStrength || 'good'}"></div>
                            </div>
                        ` : ''}
                    </div>
                </div>
                
                <div class="flex items-center text-xs text-gray-500 dark:text-gray-400 space-x-3">
                    <div class="flex items-center">
                        <i class="fas fa-desktop ${platformClass} mr-1"></i>
                        <span>${device.platform || 'Unbekannt'}</span>
                    </div>
                    <div class="flex items-center">
                        <i class="fas fa-globe ${browserClass} mr-1"></i>
                        <span>${device.browser || 'Unbekannt'}</span>
                    </div>
                </div>
                
                ${device.lastSeen && !device.online ? `
                    <p class="text-xs text-gray-400 mt-1">
                        Zuletzt online: ${new Date(device.lastSeen).toLocaleString()}
                    </p>
                ` : ''}
            </div>
            
            <div class="flex flex-col space-y-2 flex-shrink-0">
                <button class="edit-name text-gray-500 hover:text-gray-700 touch-button" data-device-id="${device.id}" title="Namen bearbeiten">
                    <i class="fas fa-edit text-sm"></i>
                </button>
                <button class="toggle-pin text-${device.pinned ? 'yellow' : 'gray'}-500 hover:text-${device.pinned ? 'yellow' : 'gray'}-700 touch-button" data-device-id="${device.id}" title="${device.pinned ? 'Abpinnten' : 'Anpinnen'}">
                    <i class="fas fa-star${device.pinned ? '' : '-o'} text-sm"></i>
                </button>
                ${device.online ? `
                <button class="send-files text-orange-500 hover:text-orange-700 touch-button" data-device-id="${device.id}" title="Dateien senden">
                    <i class="fas fa-paper-plane text-sm"></i>
                </button>
                ` : `
                <button class="text-gray-300 touch-button" disabled title="Gerät offline">
                    <i class="fas fa-paper-plane text-sm"></i>
                </button>
                `}
            </div>
        `;
        
        // Event-Listener für die Buttons
        const editButton = deviceCard.querySelector('.edit-name');
        editButton.addEventListener('click', (e) => {
            e.stopPropagation();
            showEditNameModal(device);
        });
        
        const pinButton = deviceCard.querySelector('.toggle-pin');
        pinButton.addEventListener('click', (e) => {
            e.stopPropagation();
            togglePinDevice(device.id);
        });
        
        if (device.online) {
            const sendButton = deviceCard.querySelector('.send-files');
            sendButton.addEventListener('click', (e) => {
                e.stopPropagation();
                sendFilesToDevice(device);
            });
            
            // Klick auf die Karte sendet auch Dateien
            deviceCard.addEventListener('click', () => {
                if (selectedFiles.length > 0) {
                    sendFilesToDevice(device);
                } else {
                    showToast('❌ Bitte wählen Sie zuerst Dateien aus', 'error');
                }
            });
            deviceCard.classList.add('cursor-pointer');
        } else {
            deviceCard.classList.add('cursor-not-allowed');
        }
        
        devicesList.appendChild(deviceCard);
    }
    
    // Transfer-Fortschritt Modal Funktionen
    function showTransferProgress(transfer) {
        currentTransfer = transfer;
        transferStartTime = Date.now();
        
        transferProgressTitle.textContent = `Übertragung an ${transfer.targetDevice}`;
        transferFileName.textContent = transfer.currentFile || 'Datei wird vorbereitet...';
        transferFileProgress.textContent = '0%';
        transferProgressBar.style.width = '0%';
        transferSpeed.textContent = 'Geschwindigkeit: Berechne...';
        transferTime.textContent = 'Verbleibend: Berechne...';
        
        transferProgressModal.classList.remove('hidden');
    }

    function cancelCurrentTransfer() {
        if (currentTransfer && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'fileCancel',
                transferId: currentTransfer.id
            }));
            
            activeTransfers.delete(currentTransfer.id);
            updateActiveTransfers();
            showToast('❌ Übertragung abgebrochen', 'info');
        }
        transferProgressModal.classList.add('hidden');
        currentTransfer = null;
    }

    function togglePauseTransfer() {
        if (currentTransfer) {
            const isPaused = currentTransfer.status === 'paused';
            currentTransfer.status = isPaused ? 'transferring' : 'paused';
            
            pauseTransfer.innerHTML = isPaused ? 
                '<i class="fas fa-pause mr-1"></i>Pausieren' : 
                '<i class="fas fa-play mr-1"></i>Fortsetzen';
            
            showToast(isPaused ? '▶️ Übertragung fortgesetzt' : '⏸️ Übertragung pausiert', 'info');
            
            if (!isPaused) {
                // Fortsetzungslogik hier implementieren
                transferStartTime = Date.now() - (currentTransfer.pausedTime || 0);
            } else {
                currentTransfer.pausedTime = Date.now() - transferStartTime;
            }
        }
    }

    function showReceivedFiles() {
        receivedSection.classList.remove('hidden');
        receivedSection.scrollIntoView({ behavior: 'smooth' });
    }

    function updateMobileDownloadBadge() {
        const totalFiles = Array.from(receivedFilesData.values()).reduce((sum, transfer) => sum + transfer.files.length, 0);
        if (totalFiles > 0) {
            mobileDownloadBadge.textContent = totalFiles;
            mobileDownloadBadge.classList.remove('hidden');
            mobileDownloadBtn.classList.add('pulse-animation');
        } else {
            mobileDownloadBadge.classList.add('hidden');
            mobileDownloadBtn.classList.remove('pulse-animation');
        }
    }

    function updateRoomDeviceDisplay(deviceCount) {
        console.log('👥 Aktualisiere Raum-Geräte-Anzeige:', deviceCount);
        
        if (roomDeviceCount) {
            roomDeviceCount.textContent = deviceCount;
        }
        
        if (headerDeviceCount) {
            headerDeviceCount.textContent = deviceCount;
        }
        
        if (roomDeviceHeader) {
            if (deviceCount > 0 && currentRoom) {
                roomDeviceHeader.classList.remove('hidden');
            } else {
                roomDeviceHeader.classList.add('hidden');
            }
        }
    }
    
    // Erweiterte eingehende Dateien Behandlung
    function showIncomingFilesModal(files, fromDevice, fromDeviceId, transferId, totalSize, supportsChunks) {
        pendingIncomingFiles = {
            files: files,
            fromDevice: fromDevice,
            fromDeviceId: fromDeviceId,
            transferId: transferId,
            totalSize: totalSize,
            supportsChunks: supportsChunks || false
        };
        
        incomingFrom.textContent = `${fromDevice} möchte ${files.length} Datei(en) senden:`;
        incomingTotalSize.textContent = formatFileSize(totalSize);
        incomingFilesList.innerHTML = '';
        
        files.forEach((fileInfo, index) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item bg-gray-50 rounded-lg p-2 flex items-center justify-between dark:bg-gray-600';
            
            const fileIcon = getFileIcon(fileInfo.type);
            const fileType = getFileType(fileInfo.type);
            
            fileItem.innerHTML = `
                <div class="flex items-center space-x-2 min-w-0 flex-grow">
                    <div class="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center flex-shrink-0">
                        <i class="${fileIcon} text-blue-500 text-sm"></i>
                    </div>
                    <div class="min-w-0 flex-grow">
                        <p class="font-medium text-gray-800 text-sm truncate dark:text-white">${fileInfo.name}</p>
                        <div class="flex items-center space-x-2 mt-1">
                            <span class="file-type-badge file-type-${fileType}">${getFileTypeName(fileInfo.type)}</span>
                            <span class="text-xs text-gray-500 dark:text-gray-400">${formatFileSize(fileInfo.size)}</span>
                        </div>
                    </div>
                </div>
            `;
            
            incomingFilesList.appendChild(fileItem);
        });
        
        incomingFilesModal.classList.remove('hidden');
    }

    function rejectIncomingFiles() {
        if (pendingIncomingFiles && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'transferRejected',
                fromDeviceId: pendingIncomingFiles.fromDeviceId,
                transferId: pendingIncomingFiles.transferId
            }));
            
            showToast('❌ Dateiübertragung abgelehnt', 'info');
            incomingFilesModal.classList.add('hidden');
            pendingIncomingFiles = null;
        }
    }

    function acceptIncomingFiles() {
        if (pendingIncomingFiles && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'transferAccepted',
                fromDeviceId: pendingIncomingFiles.fromDeviceId,
                transferId: pendingIncomingFiles.transferId
            }));

            // Speichere die Übertragungsinformationen
            receivedFilesData.set(pendingIncomingFiles.transferId, {
                files: pendingIncomingFiles.files,
                fromDevice: pendingIncomingFiles.fromDevice,
                fromDeviceId: pendingIncomingFiles.fromDeviceId,
                totalSize: pendingIncomingFiles.totalSize,
                timestamp: new Date(),
                status: 'accepted'
            });

            // Aktualisiere die empfangenen Dateien Anzeige
            updateReceivedFilesDisplay();
            receivedSection.classList.remove('hidden');
            
            showToast('✅ Dateien wurden angenommen und können jetzt heruntergeladen werden', 'success');
            incomingFilesModal.classList.add('hidden');
            pendingIncomingFiles = null;
        }
    }
    
    // Empfangene Dateien verwalten
    function updateReceivedFilesDisplay() {
        receivedFiles.innerHTML = '';
        
        if (receivedFilesData.size === 0) {
            receivedFiles.innerHTML = `
                <div class="text-center py-8 text-gray-500 dark:text-gray-400">
                    <i class="fas fa-inbox text-3xl mb-3"></i>
                    <p class="text-sm">Noch keine empfangenen Dateien</p>
                    <p class="text-xs mt-1">Akzeptierte Dateien erscheinen hier</p>
                </div>
            `;
            receivedFilesCount.textContent = '0';
            updateMobileDownloadBadge();
            return;
        }

        let totalFiles = 0;
        
        receivedFilesData.forEach((transferData, transferId) => {
            transferData.files.forEach((fileInfo, fileIndex) => {
                totalFiles++;
                
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item bg-green-50 border border-green-200 rounded-lg p-3 flex items-center justify-between slide-up dark:bg-green-900/20 dark:border-green-700';
                
                const fileIcon = getFileIcon(fileInfo.type);
                const fileType = getFileType(fileInfo.type);
                
                fileItem.innerHTML = `
                    <div class="flex items-center space-x-3 min-w-0 flex-grow">
                        <div class="w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center flex-shrink-0 dark:bg-green-900">
                            <i class="${fileIcon} text-green-500 text-sm"></i>
                        </div>
                        <div class="min-w-0 flex-grow">
                            <p class="font-medium text-gray-800 text-sm truncate dark:text-white">${fileInfo.name}</p>
                            <div class="flex items-center space-x-2 mt-1">
                                <span class="file-type-badge file-type-${fileType}">${getFileTypeName(fileInfo.type)}</span>
                                <span class="text-xs text-gray-500 dark:text-gray-400">${formatFileSize(fileInfo.size)}</span>
                                <span class="text-xs text-gray-400">Von ${transferData.fromDevice}</span>
                            </div>
                            <p class="text-xs text-gray-400 mt-1">Empfangen: ${transferData.timestamp.toLocaleString()}</p>
                        </div>
                    </div>
                    <div class="flex space-x-2 flex-shrink-0">
                        <button class="text-blue-500 hover:text-blue-700 download-file touch-button" 
                                data-transfer-id="${transferId}" 
                                data-file-index="${fileIndex}"
                                title="Datei herunterladen">
                            <i class="fas fa-download"></i>
                        </button>
                        <button class="text-red-500 hover:text-red-700 delete-received-file touch-button"
                                data-transfer-id="${transferId}" 
                                data-file-index="${fileIndex}"
                                title="Datei löschen">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                
                receivedFiles.appendChild(fileItem);
            });
        });

        // Event-Listener für die neuen Buttons hinzufügen
        document.querySelectorAll('.download-file').forEach(button => {
            button.addEventListener('click', (e) => {
                const transferId = e.currentTarget.getAttribute('data-transfer-id');
                const fileIndex = parseInt(e.currentTarget.getAttribute('data-file-index'));
                downloadFile(transferId, fileIndex);
            });
        });

        document.querySelectorAll('.delete-received-file').forEach(button => {
            button.addEventListener('click', (e) => {
                const transferId = e.currentTarget.getAttribute('data-transfer-id');
                const fileIndex = parseInt(e.currentTarget.getAttribute('data-file-index'));
                deleteReceivedFile(transferId, fileIndex);
            });
        });

        receivedFilesCount.textContent = totalFiles.toString();
        updateMobileDownloadBadge();
    }

    function downloadFile(transferId, fileIndex) {
        const transferData = receivedFilesData.get(transferId);
        if (!transferData) {
            showToast('❌ Datei nicht gefunden', 'error');
            return;
        }

        const fileInfo = transferData.files[fileIndex];

        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'requestFileDownload',
                transferId: transferId,
                fileIndex: fileIndex,
                targetDeviceId: transferData.fromDeviceId,
                chunkSize: chunkSize
            }));
            
            showToast(`📥 "${fileInfo.name}" wird heruntergeladen...`, 'info');
            
            // Zeige Fortschrittsmodal für Download
            currentTransfer = {
                id: transferId,
                targetDevice: transferData.fromDevice,
                currentFile: fileInfo.name,
                totalSize: fileInfo.size,
                status: 'downloading'
            };
            showTransferProgress(currentTransfer);
        } else {
            showToast('❌ Keine Verbindung zum Server', 'error');
        }
    }

    function deleteReceivedFile(transferId, fileIndex) {
        const transferData = receivedFilesData.get(transferId);
        if (transferData) {
            // Entferne spezifische Datei
            transferData.files.splice(fileIndex, 1);
            
            // Wenn keine Dateien mehr in dieser Übertragung, entferne gesamten Transfer
            if (transferData.files.length === 0) {
                receivedFilesData.delete(transferId);
            }
            
            // Aktualisiere Anzeige
            updateReceivedFilesDisplay();
            
            // Wenn keine empfangenen Dateien mehr, verstecke Section
            if (receivedFilesData.size === 0) {
                receivedSection.classList.add('hidden');
            }
            
            showToast('🗑️ Datei gelöscht', 'info');
        }
    }

    function clearAllReceivedFiles() {
        if (receivedFilesData.size > 0) {
            if (confirm('Möchten Sie wirklich alle empfangenen Dateien löschen?')) {
                receivedFilesData.clear();
                updateReceivedFilesDisplay();
                receivedSection.classList.add('hidden');
                showToast('🗑️ Alle empfangenen Dateien gelöscht', 'info');
            }
        } else {
            showToast('❌ Keine empfangenen Dateien zum Löschen', 'error');
        }
    }
    
    // Erweiterte Hilfsfunktionen
    function getFileType(mimeType) {
        if (mimeType.startsWith('image/')) return 'image';
        if (mimeType.startsWith('video/')) return 'video';
        if (mimeType.startsWith('audio/')) return 'audio';
        if (mimeType.includes('pdf') || mimeType.includes('document') || mimeType.includes('text')) return 'document';
        if (mimeType.includes('zip') || mimeType.includes('rar') || mimeType.includes('tar')) return 'archive';
        return 'other';
    }
    
    function getFileTypeName(mimeType) {
        const types = {
            'image': 'Bild',
            'video': 'Video',
            'audio': 'Audio',
            'document': 'Dokument',
            'archive': 'Archiv',
            'other': 'Datei'
        };
        return types[getFileType(mimeType)] || 'Datei';
    }
    
    function formatTime(milliseconds) {
        const seconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        
        if (hours > 0) {
            return `${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds % 60}s`;
        } else {
            return `${seconds}s`;
        }
    }
    
    function updateConnectionStrength() {
        // Berechne Verbindungsqualität basierend auf Ping und Paketverlust
        const now = Date.now();
        const timeSinceLastPing = now - connectionStats.lastPing;
        
        if (timeSinceLastPing > 60000) {
            connectionStats.connectionStrength = 'poor';
        } else if (timeSinceLastPing > 30000) {
            connectionStats.connectionStrength = 'average';
        } else {
            connectionStats.connectionStrength = 'good';
        }
        
        updateConnectionStrengthDisplay();
    }
    
    function updateConnectionStrengthDisplay() {
        const strengthIndicators = document.querySelectorAll('.connection-strength');
        strengthIndicators.forEach(indicator => {
            const bars = indicator.querySelectorAll('.strength-bar');
            bars.forEach((bar, index) => {
                bar.className = 'strength-bar';
                if (connectionStats.connectionStrength === 'good' && index < 3) {
                    bar.classList.add('good');
                } else if (connectionStats.connectionStrength === 'average' && index < 2) {
                    bar.classList.add('average');
                } else if (connectionStats.connectionStrength === 'poor' && index < 1) {
                    bar.classList.add('poor');
                }
            });
        });
    }
    
    // Erweiterte Übertragungsverwaltung
    function updateActiveTransfers() {
        transfersList.innerHTML = '';
        
        if (activeTransfers.size === 0) {
            activeTransfersSection.classList.add('hidden');
            return;
        }
        
        activeTransfersSection.classList.remove('hidden');
        
        activeTransfers.forEach((transfer, transferId) => {
            const transferElement = document.createElement('div');
            transferElement.className = 'transfer-item bg-gray-50 rounded-lg p-3 dark:bg-gray-600';
            
            const statusClass = `status-${transfer.status}`;
            const progress = transfer.progress || 0;
            
            transferElement.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <span class="font-medium text-sm text-gray-800 dark:text-white">An: ${transfer.targetDevice}</span>
                    <span class="transfer-status ${statusClass}">${getStatusText(transfer.status)}</span>
                </div>
                <div class="flex justify-between text-xs text-gray-600 dark:text-gray-300 mb-1">
                    <span>${transfer.files.length} Datei(en)</span>
                    <span>${formatFileSize(transfer.totalSize)}</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2 dark:bg-gray-700">
                    <div class="progress-fill h-2 rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                </div>
                <div class="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-1">
                    <span>${progress}%</span>
                    <span>${transfer.startTime ? formatTime(Date.now() - transfer.startTime) : ''}</span>
                </div>
            `;
            
            transfersList.appendChild(transferElement);
        });
    }
    
    function getStatusText(status) {
        const statusTexts = {
            'pending': 'Wartend',
            'transferring': 'Übertragung',
            'completed': 'Abgeschlossen',
            'error': 'Fehler',
            'cancelled': 'Abgebrochen'
        };
        return statusTexts[status] || status;
    }
    
    // Server-Info
    function fetchServerInfo() {
        fetch('/api/server-info')
            .then(response => response.json())
            .then(data => {
                serverInfo = data;
                updateServerInfoDisplay();
            })
            .catch(error => {
                console.error('Fehler beim Abrufen der Server-Info:', error);
                serverStatus.textContent = 'Offline';
                mobileServerStatus.textContent = 'Offline';
                serverStatus.className = 'server-status server-offline';
                mobileServerStatus.className = 'server-status server-offline';
            });
    }
    
    function updateServerInfoDisplay() {
        if (serverInfo.status) {
            serverStatus.textContent = 'Online';
            mobileServerStatus.textContent = 'Online';
            serverStatus.className = 'server-status server-online';
            mobileServerStatus.className = 'server-status server-online';
        }
        
        if (serverInfo.memory) {
            const memoryText = `${serverInfo.memory.used}`;
            memoryUsage.textContent = memoryText;
            mobileMemoryUsage.textContent = memoryText;
            
            // Memory-Warnung
            const usedMB = parseInt(serverInfo.memory.used);
            if (usedMB > 400) {
                memoryUsage.className = 'memory-usage critical';
                mobileMemoryUsage.className = 'memory-usage critical';
            } else if (usedMB > 300) {
                memoryUsage.className = 'memory-usage warning';
                mobileMemoryUsage.className = 'memory-usage warning';
            }
        }
        
        // Server-Info Modal aktualisieren
        if (serverInfoModal.classList.contains('hidden')) {
            serverStatusInfo.textContent = serverInfo.status || 'Unknown';
            serverConnections.textContent = serverInfo.connections || 0;
            serverRooms.textContent = serverInfo.rooms || 0;
            serverTransfers.textContent = serverInfo.transfers || 0;
            serverMemory.textContent = serverInfo.memory ? serverInfo.memory.used : '0 MB';
            serverUptime.textContent = serverInfo.uptime ? `${Math.floor(serverInfo.uptime)}s` : '0s';
        }
    }

    function showServerInfoModal() {
        fetchServerInfo();
        serverInfoModal.classList.remove('hidden');
    }
    
    // Verbindungsstatus
    function updateConnectionStatus(connected, message) {
        const statusClass = connected ? 'connected' : 'disconnected';
        const textColor = connected ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400';
        
        statusIndicator.className = `connection-status ${statusClass}`;
        statusText.textContent = message;
        statusText.className = `dark:text-gray-300 ${textColor}`;
        
        mobileStatusIndicator.className = `connection-status ${statusClass}`;
        mobileStatusText.textContent = message;
        mobileStatusText.className = `dark:text-gray-300 ${textColor}`;
        
        // Animation für verbunden-Status
        if (connected) {
            statusIndicator.classList.add('connected');
            mobileStatusIndicator.classList.add('connected');
        } else {
            statusIndicator.classList.remove('connected');
            mobileStatusIndicator.classList.remove('connected');
        }
    }
    
    // Toast-Benachrichtigung mit Typ-Unterstützung
    function showToast(message, type = 'info') {
        const icons = {
            'success': 'fa-check-circle',
            'error': 'fa-exclamation-circle',
            'warning': 'fa-exclamation-triangle',
            'info': 'fa-info-circle'
        };
        
        const iconClasses = {
            'success': 'text-green-300',
            'error': 'text-red-300', 
            'warning': 'text-yellow-300',
            'info': 'text-blue-300'
        };
        
        // Setze Icon und Typ
        toastIcon.className = `fas ${icons[type]} ${iconClasses[type]} toast-animate-icon`;
        toastMessage.textContent = message;
        
        // Setze Toast-Klasse basierend auf Typ
        toast.className = 'toast hidden';
        toast.classList.add(`toast-${type}`);
        
        // Entferne vorhandene Progress Bar
        const existingProgress = toast.querySelector('.toast-progress');
        if (existingProgress) {
            existingProgress.remove();
        }
        
        // Füge Progress Bar hinzu
        const progressBar = document.createElement('div');
        progressBar.className = 'toast-progress';
        toast.appendChild(progressBar);
        
        // Zeige Toast mit Animation
        toast.classList.remove('hidden');
        setTimeout(() => toast.classList.add('show'), 10);
        
        // Verstecke Toast nach 4 Sekunden
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.classList.add('hidden');
            }, 400);
        }, 4000);
    }

    
    // Grundlegende Funktionen
    function sendDeviceInfo() {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'deviceInfo',
                name: getDeviceName(),
                customName: customDeviceNames[currentDeviceId] || null,
                type: getDeviceType()
            }));
        }
    }
    
    function getDeviceName() {
        const ua = navigator.userAgent;
        
        // Verbesserte Plattform-Erkennung
        if (/iPhone|iPod/.test(ua)) return "iPhone";
        else if (/iPad/.test(ua)) return "iPad";
        else if (/Android/.test(ua)) return "Android Gerät";
        else if (/Windows/.test(ua)) return "Windows PC";
        else if (/Mac/.test(ua)) return "Mac";
        else if (/Linux/.test(ua)) return "Linux PC";
        else return "Computer";
        }

        function getDeviceType() {
        const ua = navigator.userAgent;
        if (/Mobile|Android|iP(hone|od)/.test(ua)) return "mobile";
        else if (/Tablet|iPad/.test(ua)) return "tablet";
        else return "desktop";
        }

        // NEUE Funktion für genaue Platform-Erkennung
        function getPlatformInfo() {
        const ua = navigator.userAgent;
        let platform = 'Unknown';
        let browser = 'Unknown';
        
        // Platform
        if (/iPhone|iPod/.test(ua)) platform = 'iOS';
        else if (/iPad/.test(ua)) platform = 'iPadOS';
        else if (/Android/.test(ua)) platform = 'Android';
        else if (/Windows/.test(ua)) platform = 'Windows';
        else if (/Mac/.test(ua)) platform = 'macOS';
        else if (/Linux/.test(ua)) platform = 'Linux';
        
        // Browser
        if (/Chrome/.test(ua) && !/Edg/.test(ua)) browser = 'Chrome';
        else if (/Firefox/.test(ua)) browser = 'Firefox';
        else if (/Safari/.test(ua) && !/Chrome/.test(ua)) browser = 'Safari';
        else if (/Edg/.test(ua)) browser = 'Edge';
        else if (/Opera/.test(ua)) browser = 'Opera';
        
        return { platform, browser };
        }
    
    function getFileIcon(fileType) {
        if (fileType.startsWith('image/')) return 'fas fa-file-image';
        if (fileType.startsWith('video/')) return 'fas fa-file-video';
        if (fileType.startsWith('audio/')) return 'fas fa-file-audio';
        if (fileType === 'application/pdf') return 'fas fa-file-pdf';
        if (fileType.includes('text') || fileType === 'application/msword' || fileType.includes('document')) return 'fas fa-file-alt';
        if (fileType.includes('zip') || fileType.includes('rar')) return 'fas fa-file-archive';
        return 'fas fa-file';
    }
    
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Raum-Funktionen
    function createRoom() {
        const roomId = createRoomName.value.trim();
        if (!roomId) {
            showToast('❌ Bitte geben Sie einen Raumnamen ein', 'error');
            return;
        }
        
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'createRoom',
                roomId: roomId,
                roomName: roomId
            }));
        } else {
            showToast('❌ Keine Verbindung zum Server', 'error');
        }
    }
    
    function joinRoom() {
        const roomId = joinRoomName.value.trim();
        if (!roomId) {
            showToast('❌ Bitte geben Sie einen Raumnamen ein', 'error');
            return;
        }
        
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'joinRoom',
                roomId: roomId
            }));
        } else {
            showToast('❌ Keine Verbindung zum Server', 'error');
        }
    }
    
    function leaveRoom() {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'leaveRoom'
            }));
        }
    }
    
    function showRoomInterface() {
        roomSection.classList.add('hidden');
        uploadSection.classList.remove('hidden');
        devicesSection.classList.remove('hidden');
        receivedSection.classList.remove('hidden');
        roomInfo.classList.remove('hidden');
        currentRoomName.textContent = currentRoom.roomName;
    }
    
    function hideRoomInterface() {
        roomSection.classList.remove('hidden');
        uploadSection.classList.add('hidden');
        devicesSection.classList.add('hidden');
        receivedSection.classList.add('hidden');
        roomInfo.classList.add('hidden');
        devicesList.innerHTML = `
            <div class="text-center py-6 text-gray-500 dark:text-gray-400">
                <i class="fas fa-search text-2xl mb-2"></i>
                <p class="text-sm">Suche nach Geräten im Raum...</p>
            </div>
        `;
    }
    
    function updateRoomInfo(roomInfo) {
        if (roomInfo) {
            roomDeviceCount.textContent = roomInfo.deviceCount;
            headerDeviceCount.textContent = roomInfo.deviceCount;
            updateRoomDeviceDisplay(roomInfo.deviceCount);
        }
    }

    // Geräteverwaltung erweitert
    function togglePinDevice(deviceId) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'togglePinDevice',
                targetDeviceId: deviceId
            }));
            
            const device = Array.from(devices.values()).find(d => d.id === deviceId);
            if (device) {
                showToast(`📌 Gerät ${device.customName || device.name} ${device.pinned ? 'abgepinnt' : 'angepinnt'}`, 'info');
            }
        }
    }

    function refreshAvailableDevices() {
        if (ws && ws.readyState === WebSocket.OPEN) {
            // Sende Ping um Geräteliste zu aktualisieren
            ws.send(JSON.stringify({ 
                type: 'ping',
                connectionStrength: connectionStats.connectionStrength
            }));
            showToast('🔄 Geräteliste wird aktualisiert...', 'info');
        } else {
            showToast('❌ Keine Verbindung zum Server', 'error');
        }
    }

    // Edit Name Modal
    function showEditNameModal(device) {
        currentEditingDevice = device;
        const customName = customDeviceNames[device.id] || '';
        
        // Setze Icon basierend auf Gerätetyp
        const iconClass = device.type === 'mobile' ? 'fa-mobile-alt' : 
                         device.type === 'tablet' ? 'fa-tablet-alt' : 'fa-laptop';
        editDeviceIcon.className = `fas ${iconClass} platform-${device.platform.toLowerCase()}`;
        
        editDeviceOriginal.textContent = `Originalname: ${device.name}`;
        editNameInput.value = customName;
        editNameInput.placeholder = device.name;
        
        editNameModal.classList.remove('hidden');
        editNameInput.focus();
    }
    
    function saveDeviceName() {
        if (!currentEditingDevice) return;
        
        const newName = editNameInput.value.trim();
        const deviceId = currentEditingDevice.id;
        
        if (newName) {
            // Speichere Namen lokal
            customDeviceNames[deviceId] = newName;
            localStorage.setItem('customDeviceNames', JSON.stringify(customDeviceNames));
            
            // Sende Update an Server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'updateDeviceName',
                    name: newName
                }));
            }
            
            showToast('✅ Gerätename gespeichert', 'success');
            editNameModal.classList.add('hidden');
            currentEditingDevice = null;
            
            // Aktualisiere die Geräteliste
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'ping' }));
            }
        } else {
            // Wenn Name leer ist, entferne den benutzerdefinierten Namen
            delete customDeviceNames[deviceId];
            localStorage.setItem('customDeviceNames', JSON.stringify(customDeviceNames));
            
            showToast('✅ Standardname wiederhergestellt', 'success');
            editNameModal.classList.add('hidden');
            currentEditingDevice = null;
            
            // Aktualisiere die Geräteliste
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'ping' }));
            }
        }
    }

    async function handleFileComplete(data) {
        console.log('🔍 handleFileComplete aufgerufen mit:', {
            fileName: data.fileName,
            fileSize: data.fileSize,
            receivedSize: data.fileData ? data.fileData.length : 0,
            transferId: data.transferId
        });
        
        // Prüfe ob Daten vorhanden sind
        if (!data.fileData) {
            console.error('❌ Keine Dateidaten empfangen');
            showToast('❌ Dateidaten fehlen', 'error');
            return;
        }
        
        // CHUNK CHECK: Prüfe ob die Daten vollständig sind
        let base64Data = data.fileData;
        
        // Entferne Data-URL Prefix falls vorhanden
        if (base64Data.startsWith('data:')) {
            const commaIndex = base64Data.indexOf(',');
            if (commaIndex !== -1) {
                base64Data = base64Data.substring(commaIndex + 1);
            }
        }
        
        // Berechne die erwartete Base64-Länge
        const expectedBase64Length = Math.ceil(data.fileSize / 3) * 4;
        const actualBase64Length = base64Data.length;
        
        console.log('🔍 Chunk-Check:', {
            expectedBase64Length,
            actualBase64Length,
            fileSize: data.fileSize,
            difference: Math.abs(expectedBase64Length - actualBase64Length)
        });
        
        // Prüfe auf unvollständige Daten (mehr als 10% Abweichung)
        const sizeDeviation = Math.abs(expectedBase64Length - actualBase64Length) / expectedBase64Length;
        
        if (sizeDeviation > 0.1) {
            console.error('❌ Datei unvollständig - Größenabweichung:', (sizeDeviation * 100).toFixed(2) + '%');
            showToast('❌ Datei unvollständig - bitte erneut senden', 'error');
            
            // Frage beim Server nach fehlenden Daten nach
            if (ws && ws.readyState === WebSocket.OPEN && data.transferId) {
                ws.send(JSON.stringify({
                    type: 'requestMissingData',
                    transferId: data.transferId,
                    fileName: data.fileName,
                    receivedSize: actualBase64Length,
                    expectedSize: expectedBase64Length
                }));
            }
            return;
        }
        
        try {
            console.log('🔧 Verarbeite Dateidaten...');
            
            // Bereinige den Base64-String
            let cleanBase64 = base64Data.replace(/[^A-Za-z0-9+/]/g, '');
            
            // Stelle sicher, dass die Länge durch 4 teilbar ist (Base64 Padding)
            while (cleanBase64.length % 4 !== 0) {
                cleanBase64 += '=';
            }
            
            console.log('⏳ Konvertiere Base64 zu Blob...');
            console.log('📊 Base64 Länge:', cleanBase64.length);
            
            try {
                // Versuche Base64 zu decodieren
                const binaryString = atob(cleanBase64);
                const bytes = new Uint8Array(binaryString.length);
                
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                const blob = new Blob([bytes], { 
                    type: data.fileType || 'application/octet-stream' 
                });
                
                console.log('✅ Blob erstellt, Größe:', blob.size);
                
                // FINALER CHUNK CHECK: Vergleiche tatsächliche mit erwarteter Größe
                if (Math.abs(blob.size - data.fileSize) > 1000) { // Toleranz von 1KB
                    console.error('❌ Dateigröße stimmt nicht überein:', {
                        erwartet: data.fileSize,
                        erhalten: blob.size,
                        differenz: data.fileSize - blob.size
                    });
                    
                    showToast('❌ Datei beschädigt - Größe stimmt nicht', 'error');
                    return;
                }
                
                if (blob.size === 0) {
                    throw new Error('Blob ist leer');
                }
                
                // Download starten
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = data.fileName;
                
                document.body.appendChild(a);
                
                console.log('🖱️ Starte Download...');
                a.click();
                
                // Aufräumen
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    console.log('🧹 Aufgeräumt');
                }, 100);
                
                console.log(`✅ Download gestartet: ${data.fileName}`);
                showToast(`✅ "${data.fileName}" erfolgreich heruntergeladen`, 'success');
                
            } catch (decodeError) {
                console.error('❌ Base64 Decodierung fehlgeschlagen:', decodeError);
                
                // Alternative Methode: Versuche es mit fetch falls es eine URL ist
                if (data.fileData.startsWith('data:')) {
                    console.log('🔄 Versuche alternative Download-Methode...');
                    fetch(data.fileData)
                        .then(response => {
                            if (!response.ok) throw new Error('Network response was not ok');
                            return response.blob();
                        })
                        .then(blob => {
                            // Chunk-Check für alternative Methode
                            if (Math.abs(blob.size - data.fileSize) > 1000) {
                                throw new Error('Dateigröße stimmt nicht überein');
                            }
                            
                            const url = window.URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = data.fileName;
                            a.click();
                            
                            setTimeout(() => {
                                window.URL.revokeObjectURL(url);
                            }, 100);
                            
                            showToast(`✅ "${data.fileName}" heruntergeladen (alternative Methode)`, 'success');
                        })
                        .catch(fetchError => {
                            console.error('❌ Alternative Methode fehlgeschlagen:', fetchError);
                            showToast('❌ Download mit beiden Methoden fehlgeschlagen', 'error');
                        });
                } else {
                    throw decodeError;
                }
            }
            
            // Erfolgreich in empfangene Dateien aufnehmen
            const transferId = data.transferId || `received-${Date.now()}`;
            receivedFilesData.set(transferId, {
                files: [{
                    name: data.fileName,
                    size: data.fileSize,
                    type: data.fileType
                }],
                fromDevice: data.fromDevice || 'Unbekannt',
                timestamp: new Date(),
                status: 'completed'
            });
            
            updateReceivedFilesDisplay();
            receivedSection.classList.remove('hidden');
            
        } catch (error) {
            console.error('❌ Fehler beim Download:', error);
            showToast(`❌ Download fehlgeschlagen: ${error.message}`, 'error');
            
            // Debug-Informationen
            console.log('🐛 Debug-Informationen:', {
                fileName: data.fileName,
                fileSize: data.fileSize,
                dataType: typeof data.fileData,
                dataLength: data.fileData ? data.fileData.length : 0
            });
        }
    }

    // Datei-Daten Empfang und Verarbeitung
    function handleFileData(data) {
        console.log(`📥 Datei-Daten empfangen: ${data.fileName}`, {
            chunkIndex: data.chunkIndex,
            totalChunks: data.totalChunks,
            dataLength: data.fileData ? data.fileData.length : 0
        });

        // Initialisiere Chunk-Speicher für diese Übertragung
        if (!fileDataStorage.has(data.transferId)) {
            fileDataStorage.set(data.transferId, {
                fileName: data.fileName,
                fileType: data.fileType,
                fileSize: data.fileSize,
                chunks: [],
                receivedSize: 0,
                totalChunks: data.totalChunks || 1
            });
        }

        const fileData = fileDataStorage.get(data.transferId);
        
        // Speichere Chunk an der richtigen Position
        if (data.chunkIndex !== undefined) {
            fileData.chunks[data.chunkIndex] = data.fileData;
        } else {
            // Fallback für einzelne Chunks
            fileData.chunks[0] = data.fileData;
        }
        
        // Aktualisiere empfangene Größe
        fileData.receivedSize += data.fileData ? data.fileData.length : 0;

        // Prüfe ob alle Chunks empfangen wurden
        const allChunksReceived = fileData.chunks.length === fileData.totalChunks && 
                                !fileData.chunks.includes(undefined);

        if (allChunksReceived || data.chunkIndex === undefined) {
            console.log(`✅ Alle Chunks empfangen für: ${data.fileName}`);
            
            // Kombiniere alle Chunks
            const combinedData = fileData.chunks.join('');
            processCompleteFile(fileData, combinedData, data.transferId);
            
            // Lösche aus dem Speicher
            fileDataStorage.delete(data.transferId);
        } else {
            console.log(`📊 Chunk-Fortschritt: ${fileData.chunks.filter(c => c).length}/${fileData.totalChunks}`);
            
            // Sende Bestätigung für empfangenen Chunk
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'chunkReceived',
                    transferId: data.transferId,
                    chunkIndex: data.chunkIndex,
                    totalChunks: data.totalChunks
                }));
            }
        }
    }
    

    // Theme umschalten
    function toggleTheme() {
        if (document.documentElement.classList.contains('dark')) {
            document.documentElement.classList.remove('dark');
            localStorage.setItem('theme', 'light');
            themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
        } else {
            document.documentElement.classList.add('dark');
            localStorage.setItem('theme', 'dark');
            themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        }
    }

    // Verbesserte Fehlerbehandlung
    window.addEventListener('error', (event) => {
        console.error('Globaler Fehler:', event.error);
        showToast('❌ Ein unerwarteter Fehler ist aufgetreten', 'error');
    });

    window.addEventListener('unhandledrejection', (event) => {
        console.error('Nicht behandelte Promise-Ablehnung:', event.reason);
        showToast('❌ Ein Systemfehler ist aufgetreten', 'error');
    });

    // Offline-Erkennung
    window.addEventListener('online', () => {
        showToast('✅ Verbindung wiederhergestellt', 'success');
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            connectWebSocket();
        }
    });

    window.addEventListener('offline', () => {
        showToast('❌ Verbindung unterbrochen', 'error');
        updateConnectionStatus(false, 'Offline');
    });

    // Beforeunload Handler für sauberes Schließen
    window.addEventListener('beforeunload', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
            // Sende Leave Room wenn in einem Raum
            if (currentRoom) {
                ws.send(JSON.stringify({ type: 'leaveRoom' }));
            }
            
            // Kurz warten damit Nachricht gesendet werden kann
            setTimeout(() => {
                ws.close(1000, 'Page unload');
            }, 100);
        }
    });

    // Performance Monitoring
    let performanceMetrics = {
        pageLoadTime: Date.now() - (performance.timing ? performance.timing.navigationStart : Date.now()),
        transfersCompleted: 0,
        totalDataTransferred: 0
    };

    // Export für Debugging - KORRIGIERTE VERSION
    window.ETKnShare = {
        debug: {
            getConnectionStats: () => connectionStats,
            getWebSocketState: () => ws ? {
                readyState: ws.readyState,
                url: ws.url,
                bufferedAmount: ws.bufferedAmount
            } : null,
            forceReconnect: () => {
                console.log('🔄 Erzwinge Reconnect...');
                reconnectAttempts = 0;
                connectWebSocket();
            },
            simulateNetworkLoss: () => {
                if (ws) {
                    console.log('🔌 Simuliere Netzwerkverlust...');
                    ws.close(1006, 'Simulated network loss');
                }
            },
            clearClientId: () => {
                localStorage.removeItem('websocket_client_id');
                localStorage.removeItem('lastSessionId');
                console.log('🧹 Client-ID gelöscht');
                location.reload();
            }
        }
    };

    console.log('🚀 ETKn Share Client initialisiert');
    console.log('📊 Performance:', performanceMetrics);
    console.log('🔧 Debug tools verfügbar unter window.ETKnShare.debug');

    // Finale Initialisierung
    updateConnectionStrengthDisplay();
    updateReceivedFilesDisplay();

    // Verbesserte Fehlerbehandlung für nicht unterstützte Browser-APIs
    if (!('performance' in window)) {
        console.warn('⚠️ Performance API nicht unterstützt');
        performanceMetrics.pageLoadTime = Date.now();
    }

function optimizeForSafari() {
    const isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    
    if (isIOS && isSafari) {
        console.log('🍎 iOS Safari erkannt - aktiviere optimierten Modus');
        
        // Reduziere Chunk-Größe für Safari
        chunkSize = 1 * 1024 * 1024; // 1MB statt 20MB
        
        // Zeige optimierte Nachricht
        showToast('📱 iOS Safari Modus aktiviert - kleinere Dateien für beste Performance', 'info');
        
        // Füge Hinweis zur Upload-Section hinzu
        const uploadArea = document.getElementById('uploadArea');
        if (uploadArea) {
            const safariHint = document.createElement('div');
            safariHint.className = 'mt-2 text-blue-600 dark:text-blue-300 text-xs';
            safariHint.innerHTML = '<i class="fas fa-info-circle mr-1"></i> Optimiert für Safari - kleinere Dateien empfohlen';
            uploadArea.appendChild(safariHint);
        }
    }
}

// Gespeichertes Theme laden
function loadSavedTheme() {
    const savedTheme = localStorage.getItem('theme');
    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (savedTheme === 'dark' || (!savedTheme && systemPrefersDark)) {
        document.documentElement.classList.add('dark');
        themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
    } else {
        document.documentElement.classList.remove('dark');
        themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
    }
}

</script>
</body>
</html>
